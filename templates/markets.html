<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="IL9Cast - Prediction Markets">
    <title>Prediction Markets - IL9Cast</title>
    <link rel="icon" type="image/png" href="{{ url_for('static', filename='favicon.png') }}">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@400;500;600&family=Inter:wght@400;500;600&family=VT323&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='landing-style.css') }}">
</head>
<body class="dark-mode">
    <canvas id="grid-canvas"></canvas>

    <div class="site-content">
        <header>
            <a href="/" class="logo">IL9<span>Cast</span></a>
            <nav>
                <a href="/">Home</a>
                <a href="/markets" class="active">Markets</a>
                <a href="/odds">Model</a>
                <a href="/fundraising">Fundraising</a>
                <a href="/methodology">Methodology</a>
                <a href="/about">About</a>
                <a href="https://github.com/de-bayes/IL9" target="_blank" rel="noopener noreferrer" class="github-link" title="View on GitHub">GitHub</a>
            </nav>
        </header>

        <section class="hero">
            <h1>Prediction Markets</h1>
            <p class="subtitle">Aggregated odds from multiple prediction markets</p>
        </section>

        <section class="markets-content-page">
            <section class="leader-featured" id="leaderFeatured">
                <div class="leader-card">
                    <img src="" alt="" class="leader-photo" id="leaderPhoto">
                    <div class="leader-info">
                        <span class="leader-label">LEADING CANDIDATE</span>
                        <span class="leader-name" id="leaderName">Loading...</span>
                        <div class="leader-main-stat">
                            <span class="leader-main-label">Aggregate Probability</span>
                            <span class="leader-main-value" id="leaderAggregate">--%</span>
                        </div>
                        <div class="leader-divider"></div>
                        <div class="leader-sub-stats">
                            <div class="leader-sub-stat">
                                <span class="leader-sub-label">Manifold</span>
                                <span class="leader-sub-value" id="leaderManifold">--%</span>
                            </div>
                            <div class="leader-sub-stat">
                                <span class="leader-sub-label">Kalshi Last</span>
                                <span class="leader-sub-value" id="leaderKalshiLast">--%</span>
                            </div>
                            <div class="leader-sub-stat">
                                <span class="leader-sub-label">Kalshi Mid</span>
                                <span class="leader-sub-value" id="leaderKalshiMid">--%</span>
                            </div>
                            <div class="leader-sub-stat">
                                <span class="leader-sub-label">Kalshi Liq</span>
                                <span class="leader-sub-value" id="leaderKalshiLiq">--%</span>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <section class="big-odds-display" id="bigOddsDisplay">
                <div class="big-odds-candidate">
                    <span class="big-percent">--</span>
                    <span class="big-name">Loading...</span>
                </div>
            </section>

            <section class="market-chart-section">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
                    <h2 style="margin: 0;">Market Trends</h2>
                    <div class="chart-toggle" id="chartToggle">
                        <button class="toggle-btn" data-period="1d">1 Day</button>
                        <button class="toggle-btn active" data-period="7d">7 Days</button>
                        <button class="toggle-btn" data-period="all">All Time</button>
                    </div>
                </div>
                <div class="chart-wrapper">
                    <canvas id="marketTrendChart"></canvas>
                </div>
                <p class="chart-subtitle">
                    We have JSONL data upon request from Jan 15 to 30, but some AWS volume issues
                    prevented us from displaying it. The graph has data from Jan 30 and on.
                    All times displayed in Central Time (CT).
                </p>
            </section>

            <section class="weights-explainer methodology-section">
                <div class="methodology-header" onclick="toggleMarketsMethodology()">
                    <h2 style="margin: 0;">Aggregation Methodology</h2>
                    <span class="toggle-icon" id="marketsMethodologyToggle">▼</span>
                </div>
                <div class="methodology-content hidden" id="marketsMethodologyContent">
                    <div class="weights-list">
                    <div class="weight-row">
                        <span class="weight-title">Manifold Markets</span>
                        <span class="weight-percentage">40%</span>
                    </div>
                    <div class="weight-row">
                        <span class="weight-title">Kalshi (Last Price)</span>
                        <span class="weight-percentage">42%</span>
                    </div>
                    <div class="weight-row">
                        <span class="weight-title">Kalshi (Midpoint)</span>
                        <span class="weight-percentage">12%</span>
                    </div>
                    <div class="weight-row">
                        <span class="weight-title">Kalshi (Liquidity)</span>
                        <span class="weight-percentage">6%</span>
                    </div>
                </div>
                <div class="methodology-note">
                    <p><strong>Why this approach?</strong> Kalshi's 60% weight emphasizes recent trade execution (70% of Kalshi weight → 42% overall) while incorporating midpoint (20% of Kalshi weight → 12%) and liquidity-weighted pricing (10% of Kalshi weight → 6%). This reflects that last trades show real money flow.</p>
                    <p style="margin-top: 0.8rem;"><strong>Why these weights?</strong> Manifold uses an AMM with liquidity banding that concentrates market-making capital around the current probability, making prices more responsive to trades near equilibrium but requiring larger trades to move prices significantly. Kalshi's real-money order book shows actual conviction through limit orders. Last price dominates because it reflects the most recent trades where people put capital at risk.</p>
                    <p style="margin-top: 0.8rem;"><strong>Why not rely solely on Kalshi's last price?</strong> Kalshi often has immensely wide bid-ask spreads (sometimes 10-20 percentage points), meaning the last completed trade may have occurred at an unrepresentative price. A market with a 45% bid / 55% ask and a last trade at 45% only demonstrates that someone was willing to sell at the bid—not that 45% is the accurate price. The true fair value likely sits somewhere in the middle of that spread, but Kalshi's order book structure means you only observe trades at the extremes when someone crosses the spread. Manifold has none of this problem: its AMM with liquidity banding provides instant, algorithmic two-way pricing with minimal spread, always reflecting current probability estimates without the friction of waiting for counterparties.</p>
                    <p style="margin-top: 0.8rem;"><strong>Liquidity-weighted pricing:</strong> Analyzes where the last trade occurred within Kalshi's bid-ask spread to capture buying vs selling pressure. Position near the ask (buyers aggressive) shifts the price up slightly; position near the bid (sellers aggressive) shifts down. Wider spreads dampen the adjustment. This only applies to Kalshi because it uses an order book exchange—Manifold's AMM algorithmically sets prices with liquidity banding that concentrates depth around current probabilities, so order book analysis doesn't apply. Manifold's continuous pricing eliminates the information gaps that plague order book exchanges with sparse liquidity.</p>
                </div>
                <div class="formula">
                    <strong>Formula:</strong> Aggregate = (0.40 × Manifold) + (0.42 × Last) + (0.12 × Midpoint) + (0.06 × Liquidity)

                    <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">
                        <strong>Sub-calculations:</strong><br>
                        Midpoint = (yes_bid + yes_ask) / 2<br>
                        <br>
                        Liquidity = Midpoint + Shift<br>
                        &nbsp;&nbsp;where Shift = offset × 6 × spread_factor<br>
                        &nbsp;&nbsp;offset = (Last - yes_bid) / (yes_ask - yes_bid) - 0.5<br>
                        &nbsp;&nbsp;spread_factor = max(0.2, 1 - spread/10 × 0.8)<br>
                        &nbsp;&nbsp;spread = yes_ask - yes_bid<br>
                        <br>
                        <strong>Thin-market fallback:</strong> When yes_bid = 0 (no buy-side orders),
                        both Midpoint and Liquidity fall back to last_price instead.
                        A midpoint between zero and the ask is not a real price signal — it
                        would massively inflate candidates with no buyer interest.
                        For example, Mike Simmons at yes_bid=0, yes_ask=19, last_price=1
                        would incorrectly show Midpoint=9.5% instead of the correct 1%.<br>
                        <br>
                        Soft Normalization (30% strength):<br>
                        &nbsp;&nbsp;Fully_Normalized = (Raw_Aggregate / Sum_All_Aggregates) × 100<br>
                        &nbsp;&nbsp;Adjustment = Fully_Normalized - Raw_Aggregate<br>
                        &nbsp;&nbsp;Final = Raw_Aggregate + (Adjustment × 0.30)
                    </div>
                </div>
                </div>
            </section>

            <section class="calculation-breakdown" id="calculationBreakdown">
                <h2>Calculation Breakdown</h2>
                <p class="breakdown-desc">Live formula application for each candidate</p>
                <div id="breakdownContent"></div>
                <p class="breakdown-desc" style="font-size: 0.85rem; color: #a0a0a0; margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid rgba(230, 126, 34, 0.2);">
                    <strong>*</strong> = No Kalshi market available. Uses 100% of Manifold probability. Probabilities are lightly normalized (30% strength) to prevent excessive drift while preserving raw market values for top candidates.
                </p>
            </section>

            <section class="additional-markets">
                <h2>Market Sources</h2>

                <div class="expandable-market" id="manifoldMarket">
                    <button class="expand-toggle" onclick="toggleMarket('manifoldMarket')">
                        <span class="market-name">Manifold Markets</span>
                        <span class="market-preview" id="manifoldPreview">Loading...</span>
                        <span class="expand-icon">+</span>
                    </button>
                    <div class="expand-content">
                        <div class="market-candidates" id="manifoldCandidates">
                            <div class="market-candidate">
                                <span class="candidate-name">Loading...</span>
                                <span class="candidate-odds">--</span>
                            </div>
                        </div>
                        <div class="market-footer">
                            <span class="last-updated" id="manifoldUpdated">Fetching data...</span>
                            <a href="https://manifold.markets/JeromeHPowell/who-will-win-the-democratic-primary-RZdcps6dL9" target="_blank" class="market-link">View on Manifold →</a>
                        </div>
                    </div>
                </div>

                <div class="expandable-market" id="kalshiMarket">
                    <button class="expand-toggle" onclick="toggleMarket('kalshiMarket')">
                        <span class="market-name">Kalshi</span>
                        <span class="market-preview" id="kalshiPreview">Loading...</span>
                        <span class="expand-icon">+</span>
                    </button>
                    <div class="expand-content">
                        <div class="market-candidates" id="kalshiCandidates">
                            <div class="market-candidate">
                                <span class="candidate-name">Loading...</span>
                                <span class="candidate-odds">--</span>
                            </div>
                        </div>
                        <div class="market-footer">
                            <span class="last-updated" id="kalshiUpdated">Fetching data...</span>
                            <a href="https://kalshi.com/markets/kxil9d/il-9-democratic-primary/kxil9d-26" target="_blank" class="market-link">View on Kalshi →</a>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Download Data Section -->
            <section class="download-data-section">
                <h2>Download Historical Data</h2>
                <p class="download-description">Download the complete historical snapshot data (JSONL format)</p>
                <a href="/api/download/snapshots" class="download-button" download>
                    <span class="download-icon">⬇</span>
                    Download Data (JSONL)
                </a>
            </section>
        </section>
    </div>

    <style>
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            min-height: 100vh;
        }

        .markets-content-page {
            max-width: 900px;
            margin: 0 auto 4rem;
            padding: 0 2rem;
        }

        /* Leader Featured Card */
        .leader-featured {
            margin: 0 0 2rem 0;
        }

        .leader-card {
            display: flex;
            gap: 2rem;
            padding: 2.5rem;
            background: rgba(26, 26, 26, 0.5);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 2px solid rgba(230, 126, 34, 0.5);
            border-radius: 12px;
        }

        .leader-photo {
            width: 140px;
            height: 140px;
            border-radius: 8px;
            object-fit: cover;
            flex-shrink: 0;
            opacity: 0.95;
        }

        .leader-info {
            display: flex;
            flex-direction: column;
            justify-content: center;
            flex: 1;
        }

        .leader-label {
            font-size: 0.8rem;
            font-weight: 600;
            letter-spacing: 0.15em;
            color: #a0a0a0;
            text-transform: uppercase;
            margin-bottom: 0.5rem;
        }

        .leader-name {
            font-size: 2.5rem;
            font-weight: 600;
            color: #e0e0e0;
            font-family: 'Cormorant Garamond', Georgia, serif;
            margin-bottom: 1rem;
        }

        .leader-main-stat {
            margin-top: 0.5rem;
        }

        .leader-main-label {
            display: block;
            font-size: 0.7rem;
            font-weight: 600;
            letter-spacing: 0.1em;
            color: #a0a0a0;
            text-transform: uppercase;
            margin-bottom: 0.25rem;
        }

        .leader-main-value {
            font-size: 3.5rem;
            font-weight: 600;
            color: #e67e22;
            font-family: 'Cormorant Garamond', Georgia, serif;
            line-height: 1;
            letter-spacing: -0.02em;
        }

        .leader-divider {
            width: 100%;
            height: 1px;
            background: rgba(230, 126, 34, 0.2);
            margin: 1rem 0;
        }

        .leader-sub-stats {
            display: flex;
            flex-wrap: wrap;
            gap: 1.25rem 2rem;
        }

        .leader-sub-stat {
            display: flex;
            flex-direction: column;
        }

        .leader-sub-label {
            font-size: 0.6rem;
            font-weight: 600;
            letter-spacing: 0.08em;
            color: #a0a0a0;
            text-transform: uppercase;
            margin-bottom: 0.2rem;
            opacity: 0.7;
        }

        .leader-sub-value {
            font-size: 1.25rem;
            font-weight: 600;
            color: #c0c0c0;
            font-family: 'Cormorant Garamond', Georgia, serif;
            line-height: 1;
        }

        @media (max-width: 600px) {
            .leader-card {
                flex-direction: column;
                align-items: center;
                text-align: center;
                padding: 1.5rem;
            }
            .leader-photo {
                width: 100px;
                height: 100px;
            }
            .leader-name {
                font-size: 1.6rem;
            }
            .leader-main-value {
                font-size: 2.5rem;
            }
            .leader-sub-stats {
                justify-content: center;
                gap: 1rem 1.5rem;
            }
            .leader-sub-value {
                font-size: 1.1rem;
            }
        }

        /* Odds Grid */
        .big-odds-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 1rem;
            margin: 0 0 2rem 0;
            text-align: center;
        }

        .big-odds-candidate {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1.5rem 0.5rem;
            background: rgba(26, 26, 26, 0.5);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 2px solid rgba(230, 126, 34, 0.3);
            border-radius: 12px;
        }

        .big-percent {
            font-size: 3.5rem;
            font-weight: 600;
            font-family: 'Cormorant Garamond', Georgia, serif;
            color: #e67e22;
            line-height: 1;
            margin-bottom: 0.5rem;
            letter-spacing: -0.02em;
        }

        .big-name {
            font-size: 0.95rem;
            color: #a0a0a0;
            font-weight: 500;
        }

        @media (max-width: 900px) {
            .big-odds-display {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (max-width: 500px) {
            .big-odds-display {
                grid-template-columns: repeat(2, 1fr);
            }
            .big-percent {
                font-size: 2.5rem;
            }
        }

        /* Chart Section */
        .market-chart-section {
            padding: 2rem;
            background: rgba(26, 26, 26, 0.5);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 2px solid rgba(230, 126, 34, 0.3);
            border-radius: 12px;
            margin-bottom: 2rem;
        }

        .chart-subtitle {
            margin-top: 1rem;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.4);
            font-style: italic;
            text-align: center;
        }

        .market-chart-section h2 {
            margin-bottom: 1.5rem;
            font-size: 1.6rem;
            color: #e67e22;
            font-family: 'Cormorant Garamond', Georgia, serif;
            font-weight: 600;
        }

        .market-chart-section .chart-wrapper {
            height: 320px;
            position: relative;
            padding: 0.5rem 0;
        }

        .chart-toggle {
            display: flex;
            gap: 0.25rem;
            background: rgba(0, 0, 0, 0.3);
            padding: 4px;
            border-radius: 8px;
            border: 1px solid rgba(230, 126, 34, 0.15);
        }

        .toggle-btn {
            padding: 0.5rem 1.25rem;
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.5);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            font-family: 'Cormorant Garamond', Georgia, serif;
            transition: all 0.25s ease;
        }

        .toggle-btn:hover {
            color: rgba(255, 255, 255, 0.8);
            background: rgba(255, 255, 255, 0.05);
        }

        .toggle-btn.active {
            background: rgba(230, 126, 34, 0.2);
            color: #e67e22;
            box-shadow: 0 0 12px rgba(230, 126, 34, 0.15);
        }

        /* Methodology Foldout */
        .weights-explainer {
            background: rgba(26, 26, 26, 0.5);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 2px solid rgba(230, 126, 34, 0.3);
            border-radius: 12px;
            padding: 0;
            margin-bottom: 2rem;
        }

        .methodology-header {
            padding: 2rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.3s ease;
        }

        .methodology-header:hover {
            background: rgba(230, 126, 34, 0.1);
        }

        .methodology-header h2 {
            font-family: 'Cormorant Garamond', Georgia, serif;
            font-size: 2rem;
            color: #e67e22;
        }

        .toggle-icon {
            font-size: 1.5rem;
            color: #e67e22;
            transition: transform 0.3s ease;
        }

        .methodology-content {
            padding: 0 2rem 2rem;
            max-height: 3000px;
            overflow: hidden;
            transition: max-height 0.5s ease, padding 0.3s ease;
        }

        .methodology-content.hidden {
            max-height: 0;
            padding: 0 2rem;
        }

        .weights-explainer h2 {
            margin-bottom: 1rem;
            font-size: 1.3rem;
            color: #e0e0e0;
        }

        .weights-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
            padding: 1rem;
            background: rgba(230, 126, 34, 0.05);
            border: 1px solid rgba(230, 126, 34, 0.15);
            border-radius: 6px;
        }

        .weight-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
        }

        .weight-title {
            font-size: 0.95rem;
            color: #e0e0e0;
            font-weight: 500;
        }

        .weight-percentage {
            font-size: 1.1rem;
            font-weight: 700;
            font-family: 'Cormorant Garamond', Georgia, serif;
            color: #e67e22;
            min-width: 50px;
            text-align: right;
        }

        .methodology-note {
            line-height: 1.7;
            color: #c0c0c0;
            margin-bottom: 1.5rem;
            padding: 1rem 1.25rem;
            background: rgba(230, 126, 34, 0.08);
            border-left: 3px solid rgba(230, 126, 34, 0.4);
            border-radius: 4px;
            font-size: 0.9rem;
        }

        .methodology-note p {
            margin: 0;
            color: #c0c0c0;
        }

        .formula {
            font-family: 'VT323', monospace;
            font-size: 1rem;
            color: #e0e0e0;
            padding: 1.5rem;
            background: rgba(230, 126, 34, 0.1);
            border-left: 4px solid #e67e22;
            border-radius: 4px;
            margin: 0;
            overflow-x: auto;
        }

        /* Calculation Breakdown */
        .calculation-breakdown {
            padding: 2.5rem;
            background: rgba(26, 26, 26, 0.5);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 2px solid rgba(230, 126, 34, 0.3);
            border-radius: 12px;
            margin-bottom: 2rem;
        }

        .calculation-breakdown h2 {
            margin-bottom: 1rem;
            font-size: 2rem;
            font-family: 'Cormorant Garamond', Georgia, serif;
            font-weight: 600;
            color: #e67e22;
        }

        .breakdown-desc {
            color: #a0a0a0;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .breakdown-desc:last-of-type {
            margin-bottom: 1.5rem;
            padding: 0.75rem 1rem;
            background: rgba(230, 126, 34, 0.08);
            border-left: 3px solid rgba(230, 126, 34, 0.4);
            border-radius: 4px;
            margin-left: 0;
            font-size: 0.85rem;
        }

        .candidate-breakdown {
            margin-bottom: 0.75rem;
            background: rgba(0, 0, 0, 0.15);
            border-left: 3px solid #e67e22;
            border-radius: 6px;
            overflow: hidden;
        }

        .breakdown-toggle {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 1.5rem;
            background: transparent;
            border: none;
            cursor: pointer;
            color: #e0e0e0;
            font-family: inherit;
            text-align: left;
            gap: 1rem;
        }

        .breakdown-toggle:hover {
            background: rgba(255, 255, 255, 0.03);
        }

        .breakdown-header {
            font-size: 1rem;
            font-weight: 600;
            color: #e0e0e0;
            flex: 1;
        }

        .breakdown-preview {
            font-size: 0.95rem;
            color: #e67e22;
            font-weight: 700;
            min-width: 60px;
            text-align: right;
        }

        .breakdown-icon {
            font-size: 1.5rem;
            color: #e67e22;
            transition: transform 0.3s ease;
        }

        .candidate-breakdown.open .breakdown-icon {
            transform: rotate(45deg);
        }

        .breakdown-details {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
            padding: 0 1.5rem;
        }

        .candidate-breakdown.open .breakdown-details {
            max-height: 400px;
            padding: 0 1.5rem 1.5rem;
        }

        .breakdown-line {
            font-size: 0.85rem;
            line-height: 1.6;
            color: #a0a0a0;
            margin-bottom: 0.4rem;
        }

        .breakdown-line strong {
            color: #e0e0e0;
            font-weight: 600;
        }

        .breakdown-result {
            margin-top: 0.8rem;
            padding-top: 0.8rem;
            border-top: 1px solid rgba(230, 126, 34, 0.2);
            font-size: 0.95rem;
            font-weight: 600;
            color: #e67e22;
        }

        /* Market Sources */
        .additional-markets {
            margin-bottom: 2rem;
        }

        .additional-markets h2 {
            margin-bottom: 1rem;
            font-size: 2rem;
            font-family: 'Cormorant Garamond', Georgia, serif;
            font-weight: 600;
            color: #e67e22;
        }

        .expandable-market {
            margin-bottom: 1rem;
            border: 2px solid rgba(230, 126, 34, 0.3);
            border-radius: 12px;
            overflow: hidden;
            background: rgba(26, 26, 26, 0.5);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
        }

        .expand-toggle {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1.25rem 1.5rem;
            background: transparent;
            border: none;
            cursor: pointer;
            color: #e0e0e0;
            font-family: inherit;
            font-size: 1rem;
            transition: background 0.2s ease;
            gap: 2rem;
        }

        .expand-toggle:hover {
            background: rgba(230, 126, 34, 0.1);
        }

        .market-name {
            font-weight: 600;
            font-size: 0.95rem;
            min-width: 140px;
        }

        .market-preview {
            color: #a0a0a0;
            font-size: 0.9rem;
            flex: 1;
            text-align: left;
        }

        .expand-icon {
            font-size: 1.5rem;
            color: #e67e22;
            transition: transform 0.3s ease;
        }

        .expandable-market.open .expand-icon {
            transform: rotate(45deg);
        }

        .expand-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
            padding: 0 1.5rem;
        }

        .expandable-market.open .expand-content {
            max-height: 500px;
            padding: 1rem 1.5rem 1.5rem;
            border-top: 1px solid rgba(230, 126, 34, 0.2);
        }

        .expand-content .market-candidates {
            margin-bottom: 1rem;
        }

        .expand-content .market-candidate {
            display: flex;
            justify-content: space-between;
            padding: 0.6rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .expand-content .market-candidate:last-child {
            border-bottom: none;
        }

        .expand-content .market-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 1rem;
            border-top: 1px solid rgba(230, 126, 34, 0.2);
            margin-top: 0.5rem;
        }

        .market-link {
            color: #e67e22;
            text-decoration: underline;
            font-size: 0.9rem;
        }

        .market-link:hover {
            opacity: 0.8;
        }

        /* Download Section */
        .download-data-section {
            padding: 2.5rem;
            background: rgba(26, 26, 26, 0.5);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 2px solid rgba(230, 126, 34, 0.3);
            border-radius: 12px;
            text-align: center;
            margin-bottom: 2rem;
        }

        .download-data-section h2 {
            margin-bottom: 0.5rem;
            font-size: 2rem;
            font-family: 'Cormorant Garamond', Georgia, serif;
            font-weight: 600;
            color: #e67e22;
        }

        .download-description {
            margin-bottom: 1.5rem;
            color: #a0a0a0;
            font-size: 0.95rem;
        }

        .download-button {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #e67e22 0%, #d35400 100%);
            color: white;
            text-decoration: none;
            border-radius: 6px;
            font-weight: 600;
            font-size: 1rem;
            transition: all 0.3s ease;
            border: none;
            cursor: pointer;
        }

        .download-button:hover {
            background: linear-gradient(135deg, #d35400 0%, #c0392b 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(230, 126, 34, 0.3);
        }

        .download-icon {
            font-size: 1.2rem;
        }

        .last-updated {
            color: #a0a0a0;
            font-size: 0.85rem;
        }

        .candidate-odds {
            color: #e67e22;
            font-weight: 600;
            font-family: 'Cormorant Garamond', Georgia, serif;
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script>
// Central Time formatter utility
function formatCentralTime(date, options = {}) {
    const defaults = {
        timeZone: 'America/Chicago',
        hour12: true
    };
    const formatter = new Intl.DateTimeFormat('en-US', { ...defaults, ...options });
    return formatter.format(date) + ' CT';
}

function toggleMarketsMethodology() {
    const content = document.getElementById('marketsMethodologyContent');
    const icon = document.getElementById('marketsMethodologyToggle');
    content.classList.toggle('hidden');
    icon.textContent = content.classList.contains('hidden') ? '▼' : '▲';
}

let marketChart = null;
let candidatesData = [];
let manifoldData = {};
let kalshiData = {};
let currentChartPeriod = '7d';

// Candidate headshot mapping
const candidateImages = {
    'daniel biss': '/static/images/candidates/biss.jpg',
    'biss': '/static/images/candidates/biss.jpg',
    'erin bushra': '/static/images/candidates/bushra.png',
    'bushra': '/static/images/candidates/bushra.png',
    'robert fine': '/static/images/candidates/fine.png',
    'fine': '/static/images/candidates/fine.png',
    'kat abugazaleh': '/static/images/candidates/katabu.png',
    'abugazaleh': '/static/images/candidates/katabu.png',
    'mike simmons': '/static/images/candidates/simmons.jpg',
    'simmons': '/static/images/candidates/simmons.jpg',
    'phil andrew': '/static/images/candidates/philandrew.png',
    'andrew': '/static/images/candidates/philandrew.png'
};

function getCandidateImage(name) {
    const normalized = name.toLowerCase().trim();
    // Try full name first
    if (candidateImages[normalized]) return candidateImages[normalized];
    // Try last name
    const lastName = normalized.split(' ').pop();
    if (candidateImages[lastName]) return candidateImages[lastName];
    // Default placeholder
    return null;
}

function toggleMarket(id) {
    const market = document.getElementById(id);
    market.classList.toggle('open');
}

function normalizeCandidate(name) {
    // Extract just the candidate name for matching
    let cleaned = name.toLowerCase()
        .replace(/^wil\s+/i, '') // Remove "Wil " prefix from Kalshi
        .replace(/^will\s+/i, '') // Remove "Will " prefix
        .replace(/\sbe\sthe\sdemocratic\snominee.*$/i, '') // Remove suffix
        .replace(/\swin.*$/i, '') // Remove "win..." suffix
        .replace(/dr\.\s+/i, '')
        .trim();

    // Handle name variations/misspellings
    const nameVariations = {
        'kat abughazaleh': 'kat abugazaleh',
        // Add more variations as needed
    };

    if (nameVariations[cleaned]) {
        cleaned = nameVariations[cleaned];
    }

    return cleaned;
}

function cleanCandidateName(name) {
    // Clean up display name for better readability
    return name
        .replace(/^wil\s+/i, '') // Remove "Wil " prefix
        .replace(/^will\s+/i, '') // Remove "Will " prefix
        .replace(/\sbe\sthe\sdemocratic\snominee.*$/i, '') // Remove question suffix
        .replace(/\?/g, '') // Remove question marks
        .trim();
}

async function calculateAggregate() {
    // Match candidates across platforms and calculate aggregated probabilities
    const aggregated = [];
    const breakdowns = [];

    // Get all unique candidates
    const allCandidates = new Set();
    Object.keys(manifoldData).forEach(name => allCandidates.add(name));
    Object.keys(kalshiData).forEach(name => allCandidates.add(name));

    allCandidates.forEach(candidateKey => {
        // Filter out Jan Schakowsky
        if (candidateKey.toLowerCase().includes('schakowsky')) {
            return;
        }

        const manifoldProb = manifoldData[candidateKey]?.probability || 0;
        const kalshiInfo = kalshiData[candidateKey] || {};
        const kalshiLast = kalshiInfo.last_price || 0;
        const kalshiMid = kalshiInfo.midpoint || 0;

        // Check if this candidate has Kalshi market
        const hasKalshi = kalshiLast > 0 || kalshiMid > 0;

        // Calculate liquidity-weighted price
        // Use pre-calculated liquidity-weighted probability from fetchKalshiData
        const kalshiLiquidity = kalshiInfo.kalshiLiquidity || kalshiMid;

        let aggregate;

        if (hasKalshi) {
            // Full weighted formula for candidates with Kalshi
            // 40% Manifold + 60% Kalshi (70% last, 20% mid, 10% liquidity)
            const manifoldContribution = 0.40 * manifoldProb;
            const kalshiLastContribution = 0.42 * kalshiLast;
            const kalshiMidContribution = 0.12 * kalshiMid;
            const kalshiLiqContribution = 0.06 * kalshiLiquidity;
            aggregate = manifoldContribution + kalshiLastContribution + kalshiMidContribution + kalshiLiqContribution;
        } else {
            // Use 100% of Manifold probability for candidates without Kalshi
            aggregate = manifoldProb;
        }

        if (aggregate > 0 || manifoldProb > 0) {
            // Use cleaned display name
            const displayName = manifoldData[candidateKey]?.displayName || kalshiInfo.displayName || candidateKey;
            const cleanName = cleanCandidateName(displayName);

            aggregated.push({
                name: cleanName,
                probability: aggregate,
                hasKalshi: hasKalshi
            });

            // Store breakdown for display
            const manifoldContribution = hasKalshi ? (0.40 * manifoldProb) : manifoldProb;
            const kalshiLastContribution = 0.27 * kalshiLast;
            const kalshiMidContribution = 0.27 * kalshiMid;
            const kalshiLiqContribution = 0.06 * kalshiLiquidity;

            breakdowns.push({
                name: cleanName,
                manifoldProb: manifoldProb.toFixed(1),
                kalshiLast: kalshiLast.toFixed(1),
                kalshiMid: kalshiMid.toFixed(1),
                kalshiLiq: kalshiLiquidity.toFixed(1),
                manifoldContribution: manifoldContribution.toFixed(2),
                kalshiLastContribution: kalshiLastContribution.toFixed(2),
                kalshiMidContribution: kalshiMidContribution.toFixed(2),
                kalshiLiqContribution: kalshiLiqContribution.toFixed(2),
                aggregate: aggregate.toFixed(1),
                hasKalshi: hasKalshi
            });
        }
    });

    // Soft normalization - only apply 30% of adjustment to keep top candidates higher
    const NORMALIZATION_STRENGTH = 0.30; // 30% normalization, 70% raw values
    const total = aggregated.reduce((sum, c) => sum + c.probability, 0);
    if (total > 0) {
        aggregated.forEach(c => {
            const fullyNormalized = (c.probability / total) * 100;
            const adjustment = fullyNormalized - c.probability;
            c.probability = c.probability + (adjustment * NORMALIZATION_STRENGTH);
        });
        breakdowns.forEach(b => {
            const oldAggregate = parseFloat(b.aggregate);
            const fullyNormalized = (oldAggregate / total) * 100;
            const adjustment = fullyNormalized - oldAggregate;
            b.normalizedAggregate = (oldAggregate + (adjustment * NORMALIZATION_STRENGTH)).toFixed(1);
        });
    }

    aggregated.sort((a, b) => b.probability - a.probability);
    breakdowns.sort((a, b) => parseFloat(b.normalizedAggregate || b.aggregate) - parseFloat(a.normalizedAggregate || a.aggregate));

    // Store aggregated data for chart updates
    candidatesData = aggregated;

    // Save snapshot as backup (backend also saves every 3 min)
    // Frontend saves only when page is viewed, backend ensures continuous collection
    await saveSnapshot(aggregated);

    renderBigOdds(aggregated);

    // Render chart with aggregated data (handles both 30d and 1h views)
    await renderMarketTrendChart(aggregated);

    renderBreakdown(breakdowns);
}

async function saveSnapshot(candidates) {
    try {
        const snapshot = {
            candidates: candidates.map(c => ({
                name: c.name,
                probability: Math.round(c.probability * 10) / 10,
                hasKalshi: c.hasKalshi
            }))
        };

        await fetch('/api/snapshot', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(snapshot)
        });
    } catch (error) {
        console.error('Error saving snapshot:', error);
    }
}

function renderBreakdown(breakdowns) {
    const container = document.getElementById('breakdownContent');

    container.innerHTML = breakdowns.map((b, idx) => {
        const asterisk = !b.hasKalshi ? '*' : '';
        const finalProb = b.normalizedAggregate || b.aggregate;

        let calculationHTML;
        if (b.hasKalshi) {
            calculationHTML = `
                <div class="breakdown-line"><strong>Manifold:</strong> ${b.manifoldProb}%</div>
                <div class="breakdown-line"><strong>Kalshi Last Price:</strong> ${b.kalshiLast}%</div>
                <div class="breakdown-line"><strong>Kalshi Midpoint:</strong> ${b.kalshiMid}%</div>
                <div class="breakdown-line"><strong>Kalshi Liquidity-Weighted:</strong> ${b.kalshiLiq}%</div>
                <div class="breakdown-line" style="margin-top: 0.8rem;">
                    <strong>Calculation:</strong><br>
                    (0.40 × ${b.manifoldProb}) + (0.27 × ${b.kalshiLast}) + (0.27 × ${b.kalshiMid}) + (0.06 × ${b.kalshiLiq})<br>
                    = ${b.manifoldContribution} + ${b.kalshiLastContribution} + ${b.kalshiMidContribution} + ${b.kalshiLiqContribution}
                </div>
                <div class="breakdown-result">= ${b.aggregate}%</div>
                ${b.normalizedAggregate ? `<div class="breakdown-line" style="margin-top: 0.5rem; color: #a0a0a0;"><strong>Soft Normalized (30%):</strong> ${b.normalizedAggregate}%</div>` : ''}
            `;
        } else {
            calculationHTML = `
                <div class="breakdown-line"><strong>Manifold:</strong> ${b.manifoldProb}%</div>
                <div class="breakdown-line" style="color: #a0a0a0;"><strong>Kalshi:</strong> No market available</div>
                <div class="breakdown-line" style="margin-top: 0.8rem;">
                    <strong>Calculation:</strong><br>
                    Using 100% of Manifold probability (no Kalshi data)<br>
                    = ${b.manifoldProb}%
                </div>
                ${b.normalizedAggregate ? `<div class="breakdown-line" style="margin-top: 0.5rem; color: #a0a0a0;"><strong>Soft Normalized (30%):</strong> ${b.normalizedAggregate}%<br><em style="font-size: 0.85em;">Light normalization applied to prevent drift while preserving market values.</em></div>` : ''}
            `;
        }

        return `
        <div class="candidate-breakdown" id="breakdown-${idx}">
            <button class="breakdown-toggle" onclick="toggleBreakdown(${idx})">
                <span class="breakdown-header">${b.name}${asterisk}</span>
                <span class="breakdown-preview">${finalProb}%</span>
                <span class="breakdown-icon">+</span>
            </button>
            <div class="breakdown-details">
                ${calculationHTML}
            </div>
        </div>
        `;
    }).join('');
}

function toggleBreakdown(idx) {
    const breakdown = document.getElementById(`breakdown-${idx}`);
    breakdown.classList.toggle('open');
}

async function fetchManifoldData() {
    try {
        const response = await fetch('/api/manifold');
        const data = await response.json();

        if (data.error) {
            throw new Error(data.error);
        }

        // Extract answers with probabilities
        const answers = data.answers || [];
        const manifoldList = answers
            .map(a => ({
                name: a.text,
                probability: Math.round(a.probability * 1000) / 10
            }))
            .filter(a => a.name !== 'Other' && !a.name.toLowerCase().includes('schakowsky'))
            .sort((a, b) => b.probability - a.probability);

        // Store in lookup object
        manifoldList.forEach(c => {
            const key = normalizeCandidate(c.name);
            manifoldData[key] = {
                displayName: c.name,
                probability: c.probability
            };
        });

        renderManifoldExpanded(manifoldList);

        // Update timestamp
        const updated = new Date(data.lastBetTime || data.lastUpdatedTime);
        document.getElementById('manifoldUpdated').textContent = `Updated ${formatCentralTime(updated, {
            month: 'short', day: 'numeric', year: 'numeric',
            hour: 'numeric', minute: '2-digit'
        })}`;

        // Calculate aggregate if both data sources are ready
        if (Object.keys(kalshiData).length > 0 && Object.keys(manifoldData).length > 0) {
            console.log('Recalculating aggregate with updated Manifold data');
            await calculateAggregate();
        } else {
            console.log('Waiting for both data sources. Manifold:', Object.keys(manifoldData).length, 'Kalshi:', Object.keys(kalshiData).length);
        }

    } catch (error) {
        console.error('Error fetching Manifold data:', error);
        document.getElementById('bigOddsDisplay').innerHTML = '<p style="color: #a0a0a0;">Error loading market data</p>';
    }
}

function renderBigOdds(candidates) {
    // Update leader featured card
    if (candidates.length > 0) {
        const leader = candidates[0];
        const leaderImage = getCandidateImage(leader.name);
        const photoEl = document.getElementById('leaderPhoto');
        const nameEl = document.getElementById('leaderName');
        const aggregateEl = document.getElementById('leaderAggregate');
        const manifoldEl = document.getElementById('leaderManifold');
        const kalshiLastEl = document.getElementById('leaderKalshiLast');
        const kalshiMidEl = document.getElementById('leaderKalshiMid');
        const kalshiLiqEl = document.getElementById('leaderKalshiLiq');

        if (leaderImage) {
            photoEl.src = leaderImage;
            photoEl.alt = leader.name;
            photoEl.style.display = 'block';
        } else {
            photoEl.style.display = 'none';
        }
        nameEl.textContent = leader.name;
        aggregateEl.textContent = Math.round(leader.probability) + '%';

        // Get Manifold and Kalshi data for leader
        const leaderKey = normalizeCandidate(leader.name);
        const manifoldProb = manifoldData[leaderKey]?.probability || 0;
        const kalshiInfo = kalshiData[leaderKey] || {};
        const kalshiLast = kalshiInfo.last_price || 0;
        const kalshiMid = kalshiInfo.midpoint || 0;
        const kalshiLiq = kalshiInfo.kalshiLiquidity || 0;

        manifoldEl.textContent = manifoldProb > 0 ? manifoldProb.toFixed(1) + '%' : '--';
        kalshiLastEl.textContent = kalshiLast > 0 ? kalshiLast.toFixed(1) + '%' : '--';
        kalshiMidEl.textContent = kalshiMid > 0 ? kalshiMid.toFixed(1) + '%' : '--';
        kalshiLiqEl.textContent = kalshiLiq > 0 ? kalshiLiq.toFixed(1) + '%' : '--';
    }

    // Update other candidates grid (skip leader)
    const container = document.getElementById('bigOddsDisplay');
    container.innerHTML = candidates.slice(1, 6).map((c) => {
        const asterisk = !c.hasKalshi ? '*' : '';
        return `
        <div class="big-odds-candidate">
            <span class="big-percent">${Math.round(c.probability)}%</span>
            <span class="big-name">${c.name}${asterisk}</span>
        </div>
        `;
    }).join('');
}

function renderManifoldExpanded(candidates) {
    // Update preview
    const top = candidates[0];
    document.getElementById('manifoldPreview').textContent = `Top: ${top.name.split(' ')[1]} ${Math.round(top.probability)}%`;

    // Update expanded list
    const container = document.getElementById('manifoldCandidates');
    container.innerHTML = candidates.map(c => `
        <div class="market-candidate">
            <span class="candidate-name">${c.name}</span>
            <span class="candidate-odds">${c.probability}%</span>
        </div>
    `).join('');
}


// Known gap ranges (populated from API response)
let knownGaps = [];

function isInGap(t0, t1) {
    // Check if the segment between t0 and t1 crosses a known data gap
    for (const gap of knownGaps) {
        // Segment crosses gap if it starts before gap ends and ends after gap starts
        if (t0 < gap.end && t1 > gap.start) {
            return true;
        }
    }
    return false;
}

async function renderMarketTrendChart(candidates) {
    const ctx = document.getElementById('marketTrendChart').getContext('2d');
    const period = currentChartPeriod || '7d';

    // Fetch RDP-simplified data from backend
    let chartData = {};
    try {
        const response = await fetch(`/api/snapshots/chart?period=${period}&epsilon=0.5`);
        chartData = await response.json();
    } catch (error) {
        console.error('Error fetching chart data:', error);
    }

    const snapshots = chartData.snapshots || [];
    // Parse gap ranges from backend (detected on raw data, not RDP-simplified)
    knownGaps = (chartData.gaps || []).map(g => ({
        start: new Date(g.start).getTime(),
        end: new Date(g.end).getTime()
    }));

    console.log(`[Chart] Known gaps: ${knownGaps.length}`, knownGaps);

    if (snapshots.length < 2) {
        if (marketChart) marketChart.destroy();
        ctx.font = '14px Arial';
        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.textAlign = 'center';
        ctx.fillText('Collecting historical data... Check back soon for trend charts.', ctx.canvas.width / 2, ctx.canvas.height / 2);
        return;
    }

    // Parse all timestamps to Date objects
    const parsedSnapshots = snapshots.map(s => {
        const ts = s.timestamp;
        const date = new Date(ts.endsWith('Z') ? ts : ts + 'Z');
        return { date, snapshot: s };
    }).filter(p => !isNaN(p.date.getTime()));

    console.log(`[Chart] Period: ${period}, Data points: ${parsedSnapshots.length}`);

    // FiveThirtyEight-inspired color palette
    const colors = [
        '#008FD5',  // Blue
        '#FC4F30',  // Red/Orange
        '#6D904F',  // Green
        '#8B8B8B',  // Gray
        '#E5AE38',  // Gold
        '#810F7C'   // Purple
    ];

    // Build datasets with {x, y} point format for time scale
    const topCandidates = candidates.slice(0, 6);
    const datasets = topCandidates.map((c, idx) => {
        const data = [];
        parsedSnapshots.forEach(({ date, snapshot }) => {
            const candidateData = snapshot.candidates.find(sc => sc.name === c.name);
            if (candidateData) {
                data.push({ x: date.getTime(), y: candidateData.probability });
            }
        });

        const baseColor = colors[idx % colors.length];
        const r = parseInt(baseColor.slice(1, 3), 16);
        const g = parseInt(baseColor.slice(3, 5), 16);
        const b = parseInt(baseColor.slice(5, 7), 16);
        const fadedColor = `rgba(${r}, ${g}, ${b}, 0.4)`;

        return {
            label: c.name.split(' ').pop() || c.name,
            data: data,
            borderColor: baseColor,
            backgroundColor: 'transparent',
            borderWidth: 2.5,
            cubicInterpolationMode: 'monotone',
            tension: 0.5,
            fill: false,
            pointRadius: 0,
            pointHoverRadius: 5,
            pointBackgroundColor: baseColor,
            pointBorderColor: '#fff',
            pointBorderWidth: 1.5,
            spanGaps: true,
            segment: {
                borderColor: ctx2 => {
                    const p0 = ctx2.p0;
                    const p1 = ctx2.p1;
                    if (p0 && p1 && p0.parsed && p1.parsed) {
                        if (isInGap(p0.parsed.x, p1.parsed.x)) {
                            return fadedColor;
                        }
                    }
                    return baseColor;
                },
                borderDash: ctx2 => {
                    const p0 = ctx2.p0;
                    const p1 = ctx2.p1;
                    if (p0 && p1 && p0.parsed && p1.parsed) {
                        if (isInGap(p0.parsed.x, p1.parsed.x)) {
                            return [6, 4];
                        }
                    }
                    return [];
                }
            }
        };
    });

    if (marketChart) marketChart.destroy();

    // Determine time unit based on period
    let timeUnit, tooltipFormat;
    if (period === '1d') {
        timeUnit = 'hour';
        tooltipFormat = 'MMM d, h:mm a';
    } else if (period === '7d') {
        timeUnit = 'day';
        tooltipFormat = 'MMM d, h:mm a';
    } else {
        timeUnit = 'day';
        tooltipFormat = 'MMM d, yyyy';
    }

    // X-axis bounds: first data point to now
    const firstTime = parsedSnapshots[0].date.getTime();
    const nowTime = Date.now();

    marketChart = new Chart(ctx, {
        type: 'line',
        data: { datasets },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
                mode: 'nearest',
                axis: 'x',
                intersect: false
            },
            plugins: {
                legend: {
                    position: 'bottom',
                    labels: {
                        usePointStyle: false,
                        boxWidth: 12,
                        boxHeight: 12,
                        padding: 15,
                        color: 'rgba(255, 255, 255, 0.8)',
                        font: {
                            family: 'Arial, sans-serif',
                            size: 12,
                            weight: 'normal'
                        }
                    }
                },
                tooltip: {
                    backgroundColor: 'rgba(0, 0, 0, 0.9)',
                    titleColor: '#fff',
                    bodyColor: '#fff',
                    borderColor: 'rgba(255, 255, 255, 0.1)',
                    borderWidth: 1,
                    padding: 10,
                    cornerRadius: 3,
                    titleFont: {
                        family: 'Arial, sans-serif',
                        size: 12,
                        weight: 'bold'
                    },
                    bodyFont: {
                        family: 'Arial, sans-serif',
                        size: 11
                    },
                    callbacks: {
                        title: function(items) {
                            if (items.length > 0) {
                                const date = new Date(items[0].parsed.x);
                                return formatCentralTime(date, {
                                    month: 'short', day: 'numeric', year: 'numeric',
                                    hour: 'numeric', minute: '2-digit'
                                });
                            }
                            return '';
                        },
                        label: function(context) {
                            return `${context.dataset.label}: ${context.parsed.y?.toFixed(1) || '--'}%`;
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    max: 100,
                    ticks: {
                        stepSize: 10,
                        callback: (value) => value + '%',
                        color: 'rgba(255, 255, 255, 0.6)',
                        font: {
                            family: 'Arial, sans-serif',
                            size: 11
                        },
                        padding: 8
                    },
                    grid: {
                        color: 'rgba(255, 255, 255, 0.08)',
                        drawBorder: false,
                        lineWidth: 1
                    },
                    border: {
                        display: false
                    }
                },
                x: {
                    type: 'time',
                    min: firstTime,
                    max: nowTime,
                    time: {
                        unit: timeUnit,
                        tooltipFormat: tooltipFormat,
                        displayFormats: {
                            hour: 'h a',
                            day: 'MMM d'
                        }
                    },
                    ticks: {
                        color: 'rgba(255, 255, 255, 0.6)',
                        autoSkip: true,
                        maxTicksLimit: period === '1d' ? 12 : (period === '7d' ? 7 : 10),
                        font: {
                            family: 'Arial, sans-serif',
                            size: 10
                        },
                        maxRotation: 0,
                        callback: function(value, index, ticks) {
                            const utcDate = new Date(value);
                            const formatter = new Intl.DateTimeFormat('en-US', {
                                timeZone: 'America/Chicago',
                                hour: timeUnit === 'hour' ? 'numeric' : undefined,
                                day: timeUnit === 'day' ? 'numeric' : undefined,
                                month: timeUnit === 'day' ? 'short' : undefined,
                                hour12: true
                            });
                            return formatter.format(utcDate);
                        }
                    },
                    grid: {
                        color: 'rgba(255, 255, 255, 0.05)',
                        drawBorder: false
                    },
                    border: {
                        display: false
                    }
                }
            }
        }
    });
}

async function fetchKalshiData() {
    try {
        console.log('Fetching Kalshi data...');
        const response = await fetch('/api/kalshi');
        const data = await response.json();

        if (data.error) {
            throw new Error(data.error);
        }

        // Extract markets - each market is a candidate
        const markets = data.markets || [];

        console.log('Kalshi response received. Markets count:', markets.length);
        console.log('Kalshi markets:', markets); // Debug log
        console.log('Kalshi data full response:', data);

        const kalshiList = [];

        markets.forEach(m => {
            // Extract candidate name from subtitle or title
            let displayName = m.subtitle || m.title;

            // Filter out Jan Schakowsky
            if (displayName.toLowerCase().includes('schakowsky')) {
                return;
            }

            const last_price = m.last_price || 0;
            const yes_bid = m.yes_bid || 0;
            const yes_ask = m.yes_ask || 0;

            // Only compute a real midpoint when both sides have orders.
            // If yes_bid is 0 (no buy-side interest), midpoint between 0
            // and the ask is meaningless — fall back to last_price.
            const midpoint = (yes_bid > 0 && yes_ask > 0) ? (yes_bid + yes_ask) / 2 : last_price;

            // Extract order book volume data
            const yes_bid_volume = m.yes_bid_size || 0;
            const no_bid_volume = m.no_bid_size || 0;

            if (last_price > 0 || midpoint > 0) {
                const key = normalizeCandidate(displayName);
                const localMid = midpoint;

                // Liquidity-weighted price based on last trade position within spread
                // Only use spread when both bid and ask exist
                const spread = (yes_bid > 0 && yes_ask > 0) ? (yes_ask - yes_bid) : 0;
                let kalshiLiquidity = localMid;

                console.log(`${displayName} RAW DATA: yes_bid=${yes_bid}, yes_ask=${yes_ask}, last=${last_price}, spread=${spread.toFixed(2)}, mid=${localMid.toFixed(1)}`);

                if (spread > 0 && last_price > 0) {
                    // Liquidity weighting: where did the last trade occur within the spread?
                    // - Last price near ask (1.0) → buyers aggressive → shift up
                    // - Last price near bid (0.0) → sellers aggressive → shift down
                    // - Last price at mid (0.5) → balanced → no shift

                    // Position in spread: 0 = at bid, 0.5 = at mid, 1 = at ask
                    const positionInSpread = Math.max(0, Math.min(1, (last_price - yes_bid) / spread));

                    // Offset from midpoint: -0.5 to +0.5
                    const offsetFromMid = positionInSpread - 0.5;

                    // Spread dampening: wider spreads = less confidence in the signal
                    // At 0pp spread: factor = 1.0 (full shift potential)
                    // At 10pp spread: factor = 0.2 (heavily dampened)
                    const spreadFactor = Math.max(0.2, 1 - (spread / 10) * 0.8);

                    // Calculate shift: scale by 6 (so ±0.5 offset → ±3pp max), apply dampening
                    const rawShift = offsetFromMid * 6 * spreadFactor;

                    // Cap at ±3 percentage points
                    const priceShift = Math.max(-3, Math.min(3, rawShift));

                    kalshiLiquidity = Math.max(0, Math.min(100, localMid + priceShift));

                    console.log(`${displayName} liquidity: pos_in_spread=${positionInSpread.toFixed(2)}, offset=${offsetFromMid.toFixed(2)}, spread_factor=${spreadFactor.toFixed(2)}, shift=${priceShift.toFixed(2)}, result=${kalshiLiquidity.toFixed(1)}`);
                } else {
                    console.log(`${displayName} NO spread/last data - using midpoint ${localMid}`);
                }

                kalshiData[key] = {
                    displayName: displayName,
                    last_price: last_price,
                    yes_bid: yes_bid,
                    yes_ask: yes_ask,
                    midpoint: midpoint,
                    yes_bid_volume: yes_bid_volume,
                    no_bid_volume: no_bid_volume,
                    kalshiLiquidity: kalshiLiquidity
                };

                kalshiList.push({
                    name: cleanCandidateName(displayName),
                    probability: Math.round(last_price * 10) / 10
                });
            }
        });

        kalshiList.sort((a, b) => b.probability - a.probability);
        renderKalshiExpanded(kalshiList);

        console.log('Kalshi candidates processed:', kalshiList);
        console.log('Kalshi data object:', kalshiData);

        // Update timestamp
        document.getElementById('kalshiUpdated').textContent = `Live data - ${formatCentralTime(new Date(), {
            hour: 'numeric', minute: '2-digit', second: '2-digit'
        })}`;

        // Calculate aggregate if both Manifold and Kalshi data are ready
        if (Object.keys(manifoldData).length > 0 && Object.keys(kalshiData).length > 0) {
            console.log('Recalculating aggregate with updated Kalshi data');
            console.log('Manifold keys:', Object.keys(manifoldData));
            console.log('Kalshi keys:', Object.keys(kalshiData));
            await calculateAggregate();
        } else {
            console.log('Waiting for both data sources. Manifold:', Object.keys(manifoldData).length, 'Kalshi:', Object.keys(kalshiData).length);
        }

    } catch (error) {
        console.error('Error fetching Kalshi data:', error);
        document.getElementById('kalshiPreview').textContent = 'Error loading';
        document.getElementById('kalshiCandidates').innerHTML = '<p style="color: #a0a0a0;">Error loading Kalshi data</p>';
    }
}

function renderKalshiExpanded(candidates) {
    if (candidates.length === 0) {
        document.getElementById('kalshiPreview').textContent = 'No data';
        return;
    }

    // Update preview - use last name only
    const top = candidates[0];
    const nameParts = top.name.split(' ');
    const topName = nameParts[nameParts.length - 1]; // Get last name
    document.getElementById('kalshiPreview').textContent = `Top: ${topName} ${Math.round(top.probability)}%`;

    // Update expanded list
    const container = document.getElementById('kalshiCandidates');
    container.innerHTML = candidates.map(c => `
        <div class="market-candidate">
            <span class="candidate-name">${c.name}</span>
            <span class="candidate-odds">${c.probability}%</span>
        </div>
    `).join('');
}

function getPollingInterval() {
    const electionDay = new Date('2026-03-17');
    const today = new Date();
    const millisecondsUntilElection = electionDay - today;
    const daysUntilElection = millisecondsUntilElection / (1000 * 60 * 60 * 24);

    // Election day: poll every 1 minute
    if (daysUntilElection <= 0 && daysUntilElection > -1) {
        return 1 * 60 * 1000; // 1 minute
    }
    // Last 3 days before election: poll every 1 minute
    else if (daysUntilElection <= 3) {
        return 1 * 60 * 1000; // 1 minute
    }
    // Default: poll every 3 minutes
    else {
        return 3 * 60 * 1000; // 3 minutes
    }
}

function setupPolling() {
    // Initial fetch
    fetchManifoldData();
    fetchKalshiData();

    // Set up interval polling with dynamic intervals
    let currentInterval = null;

    function setupNextPoll() {
        const interval = getPollingInterval();

        if (currentInterval) {
            clearInterval(currentInterval);
        }

        currentInterval = setInterval(() => {
            fetchManifoldData();
            fetchKalshiData();
            setupNextPoll(); // Re-check interval after each poll in case it changed
        }, interval);

        console.log(`Polling set to every ${interval / 1000 / 60} minute(s)`);
    }

    setupNextPoll();
}

document.addEventListener('DOMContentLoaded', () => {
    // Set up chart toggle buttons
    document.querySelectorAll('.toggle-btn').forEach(btn => {
        btn.addEventListener('click', async (e) => {
            // Update button states
            document.querySelectorAll('.toggle-btn').forEach(b => b.classList.remove('active'));
            e.target.classList.add('active');

            currentChartPeriod = e.target.dataset.period;

            // Render chart with the selected period (handles both 30d and 1h)
            await renderMarketTrendChart(candidatesData);
        });
    });

    setupPolling();
});
    </script>

    <!-- GRID BACKGROUND -->
    <script>
        const canvas = document.getElementById('grid-canvas');
        const ctx = canvas.getContext('2d');
        let mouseX = -1000, mouseY = -1000;
        let targetMouseX = -1000, targetMouseY = -1000;
        const gridSize = 40, influence = 280, maxDisplacement = 15, smoothing = 0.06;
        let pointsState = null;

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            pointsState = null;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        document.addEventListener('mousemove', (e) => {
            targetMouseX = e.clientX;
            targetMouseY = e.clientY;
        });

        document.addEventListener('mouseleave', () => {
            targetMouseX = targetMouseY = -1000;
        });

        function drawGrid() {
            mouseX += (targetMouseX - mouseX) * smoothing;
            mouseY += (targetMouseY - mouseY) * smoothing;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
            ctx.lineWidth = 1;
            const cols = Math.ceil(canvas.width / gridSize) + 1;
            const rows = Math.ceil(canvas.height / gridSize) + 1;

            if (!pointsState || pointsState.length !== rows + 1) {
                pointsState = [];
                for (let row = 0; row <= rows; row++) {
                    pointsState[row] = [];
                    for (let col = 0; col <= cols; col++) {
                        pointsState[row][col] = { x: col * gridSize, y: row * gridSize };
                    }
                }
            }

            for (let row = 0; row <= rows; row++) {
                for (let col = 0; col <= cols; col++) {
                    const baseX = col * gridSize, baseY = row * gridSize;
                    let targetX = baseX, targetY = baseY;
                    const dx = baseX - mouseX, dy = baseY - mouseY;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < influence && dist > 0) {
                        const falloff = 1 - dist / influence;
                        const force = falloff * falloff * falloff * maxDisplacement;
                        const angle = Math.atan2(dy, dx);
                        targetX = baseX + Math.cos(angle) * force;
                        targetY = baseY + Math.sin(angle) * force;
                    }

                    pointsState[row][col].x += (targetX - pointsState[row][col].x) * 0.06;
                    pointsState[row][col].y += (targetY - pointsState[row][col].y) * 0.06;
                }
            }

            for (let row = 0; row <= rows; row++) {
                ctx.beginPath();
                ctx.moveTo(pointsState[row][0].x, pointsState[row][0].y);
                for (let col = 1; col <= cols; col++) {
                    const prev = pointsState[row][col - 1], curr = pointsState[row][col];
                    ctx.quadraticCurveTo(prev.x, prev.y, (prev.x + curr.x) / 2, (prev.y + curr.y) / 2);
                }
                ctx.stroke();
            }

            for (let col = 0; col <= cols; col++) {
                ctx.beginPath();
                ctx.moveTo(pointsState[0][col].x, pointsState[0][col].y);
                for (let row = 1; row <= rows; row++) {
                    const prev = pointsState[row - 1][col], curr = pointsState[row][col];
                    ctx.quadraticCurveTo(prev.x, prev.y, (prev.x + curr.x) / 2, (prev.y + curr.y) / 2);
                }
                ctx.stroke();
            }

            requestAnimationFrame(drawGrid);
        }

        drawGrid();
    </script>
</body>
</html>
