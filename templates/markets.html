{% extends "base.html" %}

{% block title %}Prediction Markets - IL9Cast{% endblock %}

{% block content %}
<div class="inner-page markets-page">
    <div class="warm-glow"></div>

    <nav class="inner-nav">
        <a href="/" class="back-link">IL9Cast</a>
        <div class="inner-nav-links">
            <a href="/odds">The Model</a>
            <a href="/markets" class="active">Markets</a>
            <a href="/fundraising">Fundraising</a>
            <a href="/methodology">Methodology</a>
            <a href="/about">About</a>
        </div>
    </nav>

    <div class="inner-content">
        <h1 class="inner-title">Prediction Markets</h1>
        <p class="page-subtitle">Aggregated odds from multiple prediction markets</p>

        <section class="big-odds-display" id="bigOddsDisplay">
            <div class="big-odds-candidate">
                <span class="big-percent">--</span>
                <span class="big-name">Loading...</span>
            </div>
        </section>

        <section class="market-chart-section">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
                <h2 style="margin: 0;">Market Trends</h2>
                <div class="chart-toggle" id="chartToggle">
                    <button class="toggle-btn active" data-period="30d">30 Days</button>
                    <button class="toggle-btn" data-period="1h">1 Hour</button>
                </div>
            </div>
            <div class="chart-wrapper">
                <canvas id="marketTrendChart"></canvas>
            </div>
        </section>

        <section class="weights-explainer">
            <h2>Aggregation Methodology</h2>
            <div class="weights-list">
                <div class="weight-row">
                    <span class="weight-title">Manifold Markets</span>
                    <span class="weight-percentage">40%</span>
                </div>
                <div class="weight-row">
                    <span class="weight-title">Kalshi (Last Price)</span>
                    <span class="weight-percentage">42%</span>
                </div>
                <div class="weight-row">
                    <span class="weight-title">Kalshi (Midpoint)</span>
                    <span class="weight-percentage">12%</span>
                </div>
                <div class="weight-row">
                    <span class="weight-title">Kalshi (Liquidity)</span>
                    <span class="weight-percentage">6%</span>
                </div>
            </div>
            <div class="methodology-note">
                <p><strong>Why this approach?</strong> Kalshi's 60% weight emphasizes recent trade execution (70% of Kalshi weight → 42% overall) while incorporating midpoint (20% of Kalshi weight → 12%) and liquidity-weighted pricing (10% of Kalshi weight → 6%). This reflects that last trades show real money flow.</p>
                <p style="margin-top: 0.8rem;"><strong>Why these weights?</strong> Manifold uses an AMM with liquidity banding that concentrates market-making capital around the current probability, making prices more responsive to trades near equilibrium but requiring larger trades to move prices significantly. Kalshi's real-money order book shows actual conviction through limit orders. Last price dominates because it reflects the most recent trades where people put capital at risk.</p>
                <p style="margin-top: 0.8rem;"><strong>Why not rely solely on Kalshi's last price?</strong> Kalshi often has immensely wide bid-ask spreads (sometimes 10-20 percentage points), meaning the last completed trade may have occurred at an unrepresentative price. A market with a 45% bid / 55% ask and a last trade at 45% only demonstrates that someone was willing to sell at the bid—not that 45% is the accurate price. The true fair value likely sits somewhere in the middle of that spread, but Kalshi's order book structure means you only observe trades at the extremes when someone crosses the spread. Manifold has none of this problem: its AMM with liquidity banding provides instant, algorithmic two-way pricing with minimal spread, always reflecting current probability estimates without the friction of waiting for counterparties.</p>
                <p style="margin-top: 0.8rem;"><strong>Liquidity-weighted pricing:</strong> Analyzes where the last trade occurred within Kalshi's bid-ask spread to capture buying vs selling pressure. Position near the ask (buyers aggressive) shifts the price up slightly; position near the bid (sellers aggressive) shifts down. Wider spreads dampen the adjustment. This only applies to Kalshi because it uses an order book exchange—Manifold's AMM algorithmically sets prices with liquidity banding that concentrates depth around current probabilities, so order book analysis doesn't apply. Manifold's continuous pricing eliminates the information gaps that plague order book exchanges with sparse liquidity.</p>
            </div>
            <div class="formula">
                <strong>Formula:</strong> Aggregate = (0.40 × Manifold) + (0.42 × Last) + (0.12 × Midpoint) + (0.06 × Liquidity)

                <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">
                    <strong>Sub-calculations:</strong><br>
                    Midpoint = (yes_bid + yes_ask) / 2<br>
                    <br>
                    Liquidity = Midpoint + Shift<br>
                    &nbsp;&nbsp;where Shift = offset × 6 × spread_factor<br>
                    &nbsp;&nbsp;offset = (Last - yes_bid) / (yes_ask - yes_bid) - 0.5<br>
                    &nbsp;&nbsp;spread_factor = max(0.2, 1 - spread/10 × 0.8)<br>
                    &nbsp;&nbsp;spread = yes_ask - yes_bid<br>
                    <br>
                    Soft Normalization (30% strength):<br>
                    &nbsp;&nbsp;Fully_Normalized = (Raw_Aggregate / Sum_All_Aggregates) × 100<br>
                    &nbsp;&nbsp;Adjustment = Fully_Normalized - Raw_Aggregate<br>
                    &nbsp;&nbsp;Final = Raw_Aggregate + (Adjustment × 0.30)
                </div>
            </div>
        </section>

        <section class="calculation-breakdown" id="calculationBreakdown">
            <h2>Calculation Breakdown</h2>
            <p class="breakdown-desc">Live formula application for each candidate</p>
            <div id="breakdownContent"></div>
            <p class="breakdown-desc" style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
                <strong>*</strong> = No Kalshi market available. Uses 100% of Manifold probability. Probabilities are lightly normalized (30% strength) to prevent excessive drift while preserving raw market values for top candidates.
            </p>
        </section>

        <section class="additional-markets">
            <h2>Market Sources</h2>

            <div class="expandable-market" id="manifoldMarket">
                <button class="expand-toggle" onclick="toggleMarket('manifoldMarket')">
                    <span class="market-name">Manifold Markets</span>
                    <span class="market-preview" id="manifoldPreview">Loading...</span>
                    <span class="expand-icon">+</span>
                </button>
                <div class="expand-content">
                    <div class="market-candidates" id="manifoldCandidates">
                        <div class="market-candidate">
                            <span class="candidate-name">Loading...</span>
                            <span class="candidate-odds">--</span>
                        </div>
                    </div>
                    <div class="market-footer">
                        <span class="last-updated" id="manifoldUpdated">Fetching data...</span>
                        <a href="https://manifold.markets/JeromeHPowell/who-will-win-the-democratic-primary-RZdcps6dL9" target="_blank" class="market-link">View on Manifold →</a>
                    </div>
                </div>
            </div>

            <div class="expandable-market" id="kalshiMarket">
                <button class="expand-toggle" onclick="toggleMarket('kalshiMarket')">
                    <span class="market-name">Kalshi</span>
                    <span class="market-preview" id="kalshiPreview">Loading...</span>
                    <span class="expand-icon">+</span>
                </button>
                <div class="expand-content">
                    <div class="market-candidates" id="kalshiCandidates">
                        <div class="market-candidate">
                            <span class="candidate-name">Loading...</span>
                            <span class="candidate-odds">--</span>
                        </div>
                    </div>
                    <div class="market-footer">
                        <span class="last-updated" id="kalshiUpdated">Fetching data...</span>
                        <a href="https://kalshi.com/markets/kxil9d/il-9-democratic-primary/kxil9d-26" target="_blank" class="market-link">View on Kalshi →</a>
                    </div>
                </div>
            </div>
        </section>

    </div>
</div>

<style scoped>
.warm-glow {
    position: fixed;
    bottom: -30%;
    right: -15%;
    width: 60%;
    height: 60%;
    background: radial-gradient(ellipse at center,
        rgba(255, 140, 60, 0.15) 0%,
        rgba(255, 100, 40, 0.1) 20%,
        rgba(255, 80, 30, 0.06) 40%,
        rgba(255, 60, 20, 0.03) 60%,
        transparent 80%);
    filter: blur(80px);
    pointer-events: none;
    z-index: 0;
}

.inner-page {
    position: relative;
}

.inner-nav, .inner-content {
    position: relative;
    z-index: 1;
}

.weights-explainer {
    background: var(--bg-card);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 2rem;
    margin-bottom: 2.5rem;
    margin-top: 2.5rem;
}

.weights-explainer h2 {
    margin-bottom: 1rem;
    font-size: 1.3rem;
    color: var(--text-primary);
}

.weights-list {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    margin-bottom: 1.5rem;
    padding: 1rem;
    background: rgba(0, 170, 220, 0.05);
    border: 1px solid rgba(0, 170, 220, 0.15);
    border-radius: 6px;
}

.weight-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.5rem 0;
}

.weight-title {
    font-size: 0.95rem;
    color: var(--text-primary);
    font-weight: 500;
}

.weight-percentage {
    font-size: 1.1rem;
    font-weight: 700;
    font-family: 'Times New Roman', Times, serif;
    color: var(--accent-primary);
    min-width: 50px;
    text-align: right;
}

.methodology-note {
    line-height: 1.7;
    color: var(--text-secondary);
    margin-bottom: 1.5rem;
    padding: 1rem 1.25rem;
    background: rgba(0, 170, 220, 0.08);
    border-left: 3px solid rgba(0, 170, 220, 0.4);
    border-radius: 4px;
    font-size: 0.9rem;
}

.methodology-note p {
    margin: 0;
    color: var(--text-secondary);
}

.formula {
    font-family: 'Courier New', monospace;
    font-size: 0.9rem;
    color: var(--text-primary);
    padding: 1rem;
    background: rgba(0, 0, 0, 0.2);
    border-left: 3px solid var(--accent-primary);
    border-radius: 4px;
    margin: 0;
    overflow-x: auto;
}

.big-odds-display {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    gap: 1rem;
    margin: 2.5rem 0;
    text-align: center;
}

.big-odds-candidate {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 1.5rem 0.5rem;
    background: var(--bg-card);
    border: 1px solid var(--border-color);
    border-radius: 8px;
}

.big-percent {
    font-size: 3.5rem;
    font-weight: 700;
    font-family: 'Times New Roman', Times, serif;
    color: var(--text-primary);
    line-height: 1;
    margin-bottom: 0.5rem;
}

.big-name {
    font-size: 0.95rem;
    color: var(--text-secondary);
    font-weight: 500;
}

@media (max-width: 900px) {
    .big-odds-display {
        grid-template-columns: repeat(3, 1fr);
    }
}

@media (max-width: 500px) {
    .big-odds-display {
        grid-template-columns: repeat(2, 1fr);
    }
    .big-percent {
        font-size: 2.5rem;
    }
}

.market-chart-section {
    margin-top: 2.5rem;
    padding: 2rem;
    background: linear-gradient(180deg, rgba(0, 20, 40, 0.6) 0%, rgba(0, 10, 25, 0.8) 100%);
    border: 1px solid rgba(0, 220, 255, 0.12);
    border-radius: 12px;
    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.03);
}

.market-chart-section h2 {
    margin-bottom: 1.5rem;
    font-size: 1.3rem;
    color: var(--text-primary);
    font-family: 'Times New Roman', Times, serif;
    font-weight: 400;
}

.market-chart-section .chart-wrapper {
    height: 320px;
    position: relative;
    padding: 0.5rem 0;
}

.calculation-breakdown {
    margin-top: 2.5rem;
    padding: 2rem;
    background: var(--bg-card);
    border: 1px solid var(--border-color);
    border-radius: 8px;
}

.calculation-breakdown h2 {
    margin-bottom: 1rem;
    font-size: 1.3rem;
    color: var(--text-primary);
}

.breakdown-desc {
    color: var(--text-secondary);
    margin-bottom: 0.5rem;
    font-size: 0.9rem;
    line-height: 1.5;
}

.breakdown-desc:last-of-type {
    margin-bottom: 1.5rem;
    padding: 0.75rem 1rem;
    background: rgba(0, 170, 220, 0.08);
    border-left: 3px solid rgba(0, 170, 220, 0.4);
    border-radius: 4px;
    margin-left: 0;
    font-size: 0.85rem;
}

.candidate-breakdown {
    margin-bottom: 0.75rem;
    background: rgba(0, 0, 0, 0.15);
    border-left: 3px solid var(--accent-primary);
    border-radius: 6px;
    overflow: hidden;
}

.breakdown-toggle {
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 1rem 1.5rem;
    background: transparent;
    border: none;
    cursor: pointer;
    color: var(--text-primary);
    font-family: inherit;
    text-align: left;
    gap: 1rem;
}

.breakdown-toggle:hover {
    background: rgba(255, 255, 255, 0.03);
}

.breakdown-header {
    font-size: 1rem;
    font-weight: 600;
    color: var(--text-primary);
    flex: 1;
}

.breakdown-preview {
    font-size: 0.95rem;
    color: var(--accent-primary);
    font-weight: 700;
    min-width: 60px;
    text-align: right;
}

.breakdown-icon {
    font-size: 1.5rem;
    color: var(--accent-primary);
    transition: transform 0.3s ease;
}

.candidate-breakdown.open .breakdown-icon {
    transform: rotate(45deg);
}

.breakdown-details {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.3s ease, padding 0.3s ease;
    padding: 0 1.5rem;
}

.candidate-breakdown.open .breakdown-details {
    max-height: 400px;
    padding: 0 1.5rem 1.5rem;
}

.breakdown-line {
    font-size: 0.85rem;
    line-height: 1.6;
    color: var(--text-secondary);
    margin-bottom: 0.4rem;
}

.breakdown-line strong {
    color: var(--text-primary);
    font-weight: 600;
}

.breakdown-result {
    margin-top: 0.8rem;
    padding-top: 0.8rem;
    border-top: 1px solid rgba(0, 170, 220, 0.2);
    font-size: 0.95rem;
    font-weight: 600;
    color: var(--accent-primary);
}

.additional-markets {
    margin-top: 2.5rem;
}

.additional-markets h2 {
    margin-bottom: 1rem;
    font-size: 1.3rem;
    color: var(--text-primary);
}

.expandable-market {
    margin-bottom: 1rem;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    overflow: hidden;
    background: var(--bg-card);
}

.expand-toggle {
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 1.25rem 1.5rem;
    background: transparent;
    border: none;
    cursor: pointer;
    color: var(--text-primary);
    font-family: inherit;
    font-size: 1rem;
    transition: background 0.2s ease;
    gap: 2rem;
}

.expand-toggle:hover {
    background: rgba(255, 255, 255, 0.03);
}

.market-name {
    font-weight: 600;
    font-size: 0.95rem;
    min-width: 140px;
}

.market-preview {
    color: var(--text-secondary);
    font-size: 0.9rem;
    flex: 1;
    text-align: left;
}

.expand-icon {
    font-size: 1.5rem;
    color: var(--accent-primary);
    transition: transform 0.3s ease;
}

.expandable-market.open .expand-icon {
    transform: rotate(45deg);
}

.expand-content {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.3s ease, padding 0.3s ease;
    padding: 0 1.5rem;
}

.expandable-market.open .expand-content {
    max-height: 500px;
    padding: 1rem 1.5rem 1.5rem;
    border-top: 1px solid var(--border-color);
}

.expand-content .market-candidates {
    margin-bottom: 1rem;
}

.expand-content .market-candidate {
    display: flex;
    justify-content: space-between;
    padding: 0.6rem 0;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
}

.expand-content .market-candidate:last-child {
    border-bottom: none;
}

.expand-content .market-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding-top: 1rem;
    border-top: 1px solid var(--border-color);
    margin-top: 0.5rem;
}

.market-link {
    color: var(--accent-primary);
    text-decoration: none;
    font-size: 0.9rem;
}

.market-link:hover {
    text-decoration: underline;
}

.chart-toggle {
    display: flex;
    gap: 0.25rem;
    background: rgba(0, 0, 0, 0.3);
    padding: 4px;
    border-radius: 8px;
    border: 1px solid rgba(255, 255, 255, 0.06);
}

.toggle-btn {
    padding: 0.5rem 1.25rem;
    background: transparent;
    border: none;
    color: rgba(255, 255, 255, 0.5);
    border-radius: 6px;
    cursor: pointer;
    font-size: 0.85rem;
    font-weight: 500;
    font-family: 'Times New Roman', Times, serif;
    transition: all 0.25s ease;
}

.toggle-btn:hover {
    color: rgba(255, 255, 255, 0.8);
    background: rgba(255, 255, 255, 0.05);
}

.toggle-btn.active {
    background: rgba(0, 220, 255, 0.15);
    color: #00DCFF;
    box-shadow: 0 0 12px rgba(0, 220, 255, 0.2);
}
</style>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
let marketChart = null;
let candidatesData = [];
let manifoldData = {};
let kalshiData = {};
let currentChartPeriod = '30d';

function toggleMarket(id) {
    const market = document.getElementById(id);
    market.classList.toggle('open');
}

function normalizeCandidate(name) {
    // Extract just the candidate name for matching
    let cleaned = name.toLowerCase()
        .replace(/^wil\s+/i, '') // Remove "Wil " prefix from Kalshi
        .replace(/^will\s+/i, '') // Remove "Will " prefix
        .replace(/\sbe\sthe\sdemocratic\snominee.*$/i, '') // Remove suffix
        .replace(/\swin.*$/i, '') // Remove "win..." suffix
        .replace(/dr\.\s+/i, '')
        .trim();

    // Handle name variations/misspellings
    const nameVariations = {
        'kat abughazaleh': 'kat abugazaleh',
        // Add more variations as needed
    };

    if (nameVariations[cleaned]) {
        cleaned = nameVariations[cleaned];
    }

    return cleaned;
}

function cleanCandidateName(name) {
    // Clean up display name for better readability
    return name
        .replace(/^wil\s+/i, '') // Remove "Wil " prefix
        .replace(/^will\s+/i, '') // Remove "Will " prefix
        .replace(/\sbe\sthe\sdemocratic\snominee.*$/i, '') // Remove question suffix
        .replace(/\?/g, '') // Remove question marks
        .trim();
}

async function calculateAggregate() {
    // Match candidates across platforms and calculate aggregated probabilities
    const aggregated = [];
    const breakdowns = [];

    // Get all unique candidates
    const allCandidates = new Set();
    Object.keys(manifoldData).forEach(name => allCandidates.add(name));
    Object.keys(kalshiData).forEach(name => allCandidates.add(name));

    allCandidates.forEach(candidateKey => {
        // Filter out Jan Schakowsky
        if (candidateKey.toLowerCase().includes('schakowsky')) {
            return;
        }

        const manifoldProb = manifoldData[candidateKey]?.probability || 0;
        const kalshiInfo = kalshiData[candidateKey] || {};
        const kalshiLast = kalshiInfo.last_price || 0;
        const kalshiMid = kalshiInfo.midpoint || 0;

        // Check if this candidate has Kalshi market
        const hasKalshi = kalshiLast > 0 || kalshiMid > 0;

        // Calculate liquidity-weighted price
        // Use pre-calculated liquidity-weighted probability from fetchKalshiData
        const kalshiLiquidity = kalshiInfo.kalshiLiquidity || kalshiMid;

        let aggregate;

        if (hasKalshi) {
            // Full weighted formula for candidates with Kalshi
            // 40% Manifold + 60% Kalshi (70% last, 20% mid, 10% liquidity)
            const manifoldContribution = 0.40 * manifoldProb;
            const kalshiLastContribution = 0.42 * kalshiLast;
            const kalshiMidContribution = 0.12 * kalshiMid;
            const kalshiLiqContribution = 0.06 * kalshiLiquidity;
            aggregate = manifoldContribution + kalshiLastContribution + kalshiMidContribution + kalshiLiqContribution;
        } else {
            // Use 100% of Manifold probability for candidates without Kalshi
            aggregate = manifoldProb;
        }

        if (aggregate > 0 || manifoldProb > 0) {
            // Use cleaned display name
            const displayName = manifoldData[candidateKey]?.displayName || kalshiInfo.displayName || candidateKey;
            const cleanName = cleanCandidateName(displayName);

            aggregated.push({
                name: cleanName,
                probability: aggregate,
                hasKalshi: hasKalshi
            });

            // Store breakdown for display
            const manifoldContribution = hasKalshi ? (0.40 * manifoldProb) : manifoldProb;
            const kalshiLastContribution = 0.27 * kalshiLast;
            const kalshiMidContribution = 0.27 * kalshiMid;
            const kalshiLiqContribution = 0.06 * kalshiLiquidity;

            breakdowns.push({
                name: cleanName,
                manifoldProb: manifoldProb.toFixed(1),
                kalshiLast: kalshiLast.toFixed(1),
                kalshiMid: kalshiMid.toFixed(1),
                kalshiLiq: kalshiLiquidity.toFixed(1),
                manifoldContribution: manifoldContribution.toFixed(2),
                kalshiLastContribution: kalshiLastContribution.toFixed(2),
                kalshiMidContribution: kalshiMidContribution.toFixed(2),
                kalshiLiqContribution: kalshiLiqContribution.toFixed(2),
                aggregate: aggregate.toFixed(1),
                hasKalshi: hasKalshi
            });
        }
    });

    // Soft normalization - only apply 30% of adjustment to keep top candidates higher
    const NORMALIZATION_STRENGTH = 0.30; // 30% normalization, 70% raw values
    const total = aggregated.reduce((sum, c) => sum + c.probability, 0);
    if (total > 0) {
        aggregated.forEach(c => {
            const fullyNormalized = (c.probability / total) * 100;
            const adjustment = fullyNormalized - c.probability;
            c.probability = c.probability + (adjustment * NORMALIZATION_STRENGTH);
        });
        breakdowns.forEach(b => {
            const oldAggregate = parseFloat(b.aggregate);
            const fullyNormalized = (oldAggregate / total) * 100;
            const adjustment = fullyNormalized - oldAggregate;
            b.normalizedAggregate = (oldAggregate + (adjustment * NORMALIZATION_STRENGTH)).toFixed(1);
        });
    }

    aggregated.sort((a, b) => b.probability - a.probability);
    breakdowns.sort((a, b) => parseFloat(b.normalizedAggregate || b.aggregate) - parseFloat(a.normalizedAggregate || a.aggregate));

    // Store aggregated data for chart updates
    candidatesData = aggregated;

    // Save snapshot as backup (backend also saves every 3 min)
    // Frontend saves only when page is viewed, backend ensures continuous collection
    await saveSnapshot(aggregated);

    renderBigOdds(aggregated);

    // Render chart with aggregated data (handles both 30d and 1h views)
    await renderMarketTrendChart(aggregated);

    renderBreakdown(breakdowns);
}

async function saveSnapshot(candidates) {
    try {
        const snapshot = {
            candidates: candidates.map(c => ({
                name: c.name,
                probability: Math.round(c.probability * 10) / 10,
                hasKalshi: c.hasKalshi
            }))
        };

        await fetch('/api/snapshot', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(snapshot)
        });
    } catch (error) {
        console.error('Error saving snapshot:', error);
    }
}

function renderBreakdown(breakdowns) {
    const container = document.getElementById('breakdownContent');

    container.innerHTML = breakdowns.map((b, idx) => {
        const asterisk = !b.hasKalshi ? '*' : '';
        const finalProb = b.normalizedAggregate || b.aggregate;

        let calculationHTML;
        if (b.hasKalshi) {
            calculationHTML = `
                <div class="breakdown-line"><strong>Manifold:</strong> ${b.manifoldProb}%</div>
                <div class="breakdown-line"><strong>Kalshi Last Price:</strong> ${b.kalshiLast}%</div>
                <div class="breakdown-line"><strong>Kalshi Midpoint:</strong> ${b.kalshiMid}%</div>
                <div class="breakdown-line"><strong>Kalshi Liquidity-Weighted:</strong> ${b.kalshiLiq}%</div>
                <div class="breakdown-line" style="margin-top: 0.8rem;">
                    <strong>Calculation:</strong><br>
                    (0.40 × ${b.manifoldProb}) + (0.27 × ${b.kalshiLast}) + (0.27 × ${b.kalshiMid}) + (0.06 × ${b.kalshiLiq})<br>
                    = ${b.manifoldContribution} + ${b.kalshiLastContribution} + ${b.kalshiMidContribution} + ${b.kalshiLiqContribution}
                </div>
                <div class="breakdown-result">= ${b.aggregate}%</div>
                ${b.normalizedAggregate ? `<div class="breakdown-line" style="margin-top: 0.5rem; color: var(--text-secondary);"><strong>Soft Normalized (30%):</strong> ${b.normalizedAggregate}%</div>` : ''}
            `;
        } else {
            calculationHTML = `
                <div class="breakdown-line"><strong>Manifold:</strong> ${b.manifoldProb}%</div>
                <div class="breakdown-line" style="color: var(--text-secondary);"><strong>Kalshi:</strong> No market available</div>
                <div class="breakdown-line" style="margin-top: 0.8rem;">
                    <strong>Calculation:</strong><br>
                    Using 100% of Manifold probability (no Kalshi data)<br>
                    = ${b.manifoldProb}%
                </div>
                ${b.normalizedAggregate ? `<div class="breakdown-line" style="margin-top: 0.5rem; color: var(--text-secondary);"><strong>Soft Normalized (30%):</strong> ${b.normalizedAggregate}%<br><em style="font-size: 0.85em;">Light normalization applied to prevent drift while preserving market values.</em></div>` : ''}
            `;
        }

        return `
        <div class="candidate-breakdown" id="breakdown-${idx}">
            <button class="breakdown-toggle" onclick="toggleBreakdown(${idx})">
                <span class="breakdown-header">${b.name}${asterisk}</span>
                <span class="breakdown-preview">${finalProb}%</span>
                <span class="breakdown-icon">+</span>
            </button>
            <div class="breakdown-details">
                ${calculationHTML}
            </div>
        </div>
        `;
    }).join('');
}

function toggleBreakdown(idx) {
    const breakdown = document.getElementById(`breakdown-${idx}`);
    breakdown.classList.toggle('open');
}

async function fetchManifoldData() {
    try {
        const response = await fetch('/api/manifold');
        const data = await response.json();

        if (data.error) {
            throw new Error(data.error);
        }

        // Extract answers with probabilities
        const answers = data.answers || [];
        const manifoldList = answers
            .map(a => ({
                name: a.text,
                probability: Math.round(a.probability * 1000) / 10
            }))
            .filter(a => a.name !== 'Other' && !a.name.toLowerCase().includes('schakowsky'))
            .sort((a, b) => b.probability - a.probability);

        // Store in lookup object
        manifoldList.forEach(c => {
            const key = normalizeCandidate(c.name);
            manifoldData[key] = {
                displayName: c.name,
                probability: c.probability
            };
        });

        renderManifoldExpanded(manifoldList);

        // Update timestamp
        const updated = new Date(data.lastBetTime || data.lastUpdatedTime);
        document.getElementById('manifoldUpdated').textContent = `Updated ${updated.toLocaleString()}`;

        // Calculate aggregate if both data sources are ready
        if (Object.keys(kalshiData).length > 0 && Object.keys(manifoldData).length > 0) {
            console.log('Recalculating aggregate with updated Manifold data');
            await calculateAggregate();
        } else {
            console.log('Waiting for both data sources. Manifold:', Object.keys(manifoldData).length, 'Kalshi:', Object.keys(kalshiData).length);
        }

    } catch (error) {
        console.error('Error fetching Manifold data:', error);
        document.getElementById('bigOddsDisplay').innerHTML = '<p style="color: var(--text-secondary);">Error loading market data</p>';
    }
}

function renderBigOdds(candidates) {
    const container = document.getElementById('bigOddsDisplay');
    container.innerHTML = candidates.slice(0, 6).map(c => {
        const asterisk = !c.hasKalshi ? '*' : '';
        return `
        <div class="big-odds-candidate">
            <span class="big-percent">${Math.round(c.probability)}%</span>
            <span class="big-name">${c.name}${asterisk}</span>
        </div>
        `;
    }).join('');
}

function renderManifoldExpanded(candidates) {
    // Update preview
    const top = candidates[0];
    document.getElementById('manifoldPreview').textContent = `Top: ${top.name.split(' ')[1]} ${Math.round(top.probability)}%`;

    // Update expanded list
    const container = document.getElementById('manifoldCandidates');
    container.innerHTML = candidates.map(c => `
        <div class="market-candidate">
            <span class="candidate-name">${c.name}</span>
            <span class="candidate-odds">${c.probability}%</span>
        </div>
    `).join('');
}


// Aggregate snapshots to reduce data points for cleaner chart lines
function aggregateSnapshots(snapshots, period) {
    if (period === '1h') {
        // For 1 hour view, show all raw points (already filtered by time range)
        return snapshots;
    }

    // For 30 days view, aggregate to hourly averages
    const hourlyBuckets = {};

    snapshots.forEach(snapshot => {
        // Parse timestamp - handle both UTC (with Z) and local (without Z)
        const ts = snapshot.timestamp;
        let date;
        if (ts.endsWith('Z')) {
            date = new Date(ts); // UTC - auto converts to local
        } else {
            const [datePart, timePart] = ts.split('T');
            const [year, month, day] = datePart.split('-').map(Number);
            const [hour, min, sec] = (timePart || '00:00:00').split(':').map(n => parseInt(n));
            date = new Date(year, month - 1, day, hour, min, sec || 0);
        }

        // Create hourKey from local time
        const hourKey = `${date.getFullYear()}-${String(date.getMonth()+1).padStart(2,'0')}-${String(date.getDate()).padStart(2,'0')}T${String(date.getHours()).padStart(2,'0')}:00:00`;

        if (!hourlyBuckets[hourKey]) {
            hourlyBuckets[hourKey] = [];
        }
        hourlyBuckets[hourKey].push(snapshot);
    });

    // Average the snapshots in each hour bucket
    const aggregated = Object.keys(hourlyBuckets).sort().map(hourKey => {
        const snapshotsInHour = hourlyBuckets[hourKey];

        // Get all unique candidate names
        const allCandidates = new Set();
        snapshotsInHour.forEach(s => {
            s.candidates.forEach(c => allCandidates.add(c.name));
        });

        // Average probability for each candidate
        const candidateAverages = Array.from(allCandidates).map(name => {
            const probs = snapshotsInHour
                .map(s => s.candidates.find(c => c.name === name)?.probability)
                .filter(p => p !== undefined);

            const avgProb = probs.reduce((sum, p) => sum + p, 0) / probs.length;
            const hasKalshi = snapshotsInHour.some(s =>
                s.candidates.find(c => c.name === name)?.hasKalshi
            );

            return {
                name: name,
                probability: avgProb,
                hasKalshi: hasKalshi
            };
        });

        return {
            timestamp: hourKey,
            candidates: candidateAverages
        };
    });

    return aggregated;
}

async function renderMarketTrendChart(candidates) {
    const ctx = document.getElementById('marketTrendChart').getContext('2d');

    // Fetch REAL historical snapshots - NO FAKE DATA
    let snapshots = [];
    try {
        const response = await fetch('/api/snapshots');
        snapshots = await response.json();
    } catch (error) {
        console.error('Error fetching historical snapshots:', error);
    }

    // If we don't have enough historical data, show a message
    if (snapshots.length < 2) {
        if (marketChart) marketChart.destroy();

        ctx.font = '14px Arial';
        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.textAlign = 'center';
        ctx.fillText('Collecting historical data... Check back soon for trend charts.', ctx.canvas.width / 2, ctx.canvas.height / 2);
        return;
    }

    // Filter snapshots by time period and aggregate for cleaner lines
    const now = new Date();
    const period = currentChartPeriod || '30d';
    let filteredSnapshots = snapshots;

    if (period === '1h') {
        const oneHourAgo = new Date(now - 60 * 60 * 1000);
        filteredSnapshots = snapshots.filter(s => {
            // Parse timestamp - handle both UTC (with Z) and local (without Z)
            const ts = s.timestamp;
            let snapshotDate;
            if (ts.endsWith('Z')) {
                snapshotDate = new Date(ts); // UTC - auto converts to local
            } else {
                const [datePart, timePart] = ts.split('T');
                const [year, month, day] = datePart.split('-').map(Number);
                const [hour, min, sec] = (timePart || '00:00:00').split(':').map(n => parseInt(n));
                snapshotDate = new Date(year, month - 1, day, hour, min, sec || 0);
            }
            return snapshotDate > oneHourAgo;
        });

        // If we don't have enough data in the last hour (due to deployment gaps),
        // show the most recent data points to ensure the chart displays something
        const MIN_DATA_POINTS = 10;
        if (filteredSnapshots.length < MIN_DATA_POINTS && snapshots.length >= MIN_DATA_POINTS) {
            // Take the last N data points regardless of time range
            filteredSnapshots = snapshots.slice(-MIN_DATA_POINTS);
        }
    }

    // Aggregate to reduce data points (hourly for 30d, raw for 1h)
    const aggregatedSnapshots = aggregateSnapshots(filteredSnapshots, period);

    // Build labels from aggregated snapshot timestamps
    const labels = aggregatedSnapshots.map((s, index) => {
        // Parse timestamp - if ends with Z, it's UTC; otherwise treat as local
        const ts = s.timestamp;
        let date;
        if (ts.endsWith('Z')) {
            // UTC timestamp - new Date() will convert to local automatically
            date = new Date(ts);
        } else {
            // Old format without Z - parse as local time components
            const [datePart, timePart] = ts.split('T');
            const [year, month, day] = datePart.split('-').map(Number);
            const [hour, min, sec] = (timePart || '00:00:00').split(':').map(n => parseInt(n));
            date = new Date(year, month - 1, day, hour, min, sec || 0);
        }

        if (period === '1h') {
            return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
        } else {
            // For 30-day view, show date and hour
            return date.toLocaleString('en-US', {
                month: 'short',
                day: 'numeric',
                hour: 'numeric',
                hour12: true
            });
        }
    });

    // FiveThirtyEight-inspired color palette: muted, professional
    const colors = [
        '#008FD5',  // Blue
        '#FC4F30',  // Red/Orange
        '#6D904F',  // Green
        '#8B8B8B',  // Gray
        '#E5AE38',  // Gold
        '#810F7C'   // Purple
    ];

    // Build datasets from REAL historical data only (aggregated for clean lines)
    const topCandidates = candidates.slice(0, 4);
    const datasets = topCandidates.map((c, idx) => {
        const data = aggregatedSnapshots.map(snapshot => {
            const candidateData = snapshot.candidates.find(sc => sc.name === c.name);
            return candidateData ? candidateData.probability : null;
        });

        return {
            label: c.name.split(' ').pop() || c.name,
            data: data,
            borderColor: colors[idx],
            backgroundColor: 'transparent',
            borderWidth: 2,
            tension: 0,  // FiveThirtyEight uses straight lines between points
            fill: false,
            pointRadius: 2,
            pointHoverRadius: 4,
            pointBackgroundColor: colors[idx],
            pointBorderColor: '#fff',
            pointBorderWidth: 1,
            spanGaps: true
        };
    });

    if (marketChart) marketChart.destroy();

    marketChart = new Chart(ctx, {
        type: 'line',
        data: { labels, datasets },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
                mode: 'index',
                intersect: false
            },
            plugins: {
                legend: {
                    position: 'bottom',
                    labels: {
                        usePointStyle: false,
                        boxWidth: 12,
                        boxHeight: 12,
                        padding: 15,
                        color: 'rgba(255, 255, 255, 0.8)',
                        font: {
                            family: 'Arial, sans-serif',
                            size: 12,
                            weight: 'normal'
                        }
                    }
                },
                tooltip: {
                    backgroundColor: 'rgba(0, 0, 0, 0.9)',
                    titleColor: '#fff',
                    bodyColor: '#fff',
                    borderColor: 'rgba(255, 255, 255, 0.1)',
                    borderWidth: 1,
                    padding: 10,
                    cornerRadius: 3,
                    titleFont: {
                        family: 'Arial, sans-serif',
                        size: 12,
                        weight: 'bold'
                    },
                    bodyFont: {
                        family: 'Arial, sans-serif',
                        size: 11
                    },
                    callbacks: {
                        label: function(context) {
                            return `${context.dataset.label}: ${context.parsed.y?.toFixed(1) || '--'}%`;
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    max: 100,
                    ticks: {
                        stepSize: 10,
                        callback: (value) => value + '%',
                        color: 'rgba(255, 255, 255, 0.6)',
                        font: {
                            family: 'Arial, sans-serif',
                            size: 11
                        },
                        padding: 8
                    },
                    grid: {
                        color: 'rgba(255, 255, 255, 0.08)',
                        drawBorder: false,
                        lineWidth: 1
                    },
                    border: {
                        display: false
                    }
                },
                x: {
                    ticks: {
                        color: 'rgba(255, 255, 255, 0.6)',
                        maxTicksLimit: 10,
                        font: {
                            family: 'Arial, sans-serif',
                            size: 10
                        },
                        maxRotation: 45,
                        minRotation: 0
                    },
                    grid: {
                        color: 'rgba(255, 255, 255, 0.05)',
                        drawBorder: false
                    },
                    border: {
                        display: false
                    }
                }
            }
        }
    });
}

async function fetchKalshiData() {
    try {
        console.log('Fetching Kalshi data...');
        const response = await fetch('/api/kalshi');
        const data = await response.json();

        if (data.error) {
            throw new Error(data.error);
        }

        // Extract markets - each market is a candidate
        const markets = data.markets || [];

        console.log('Kalshi response received. Markets count:', markets.length);
        console.log('Kalshi markets:', markets); // Debug log
        console.log('Kalshi data full response:', data);

        const kalshiList = [];

        markets.forEach(m => {
            // Extract candidate name from subtitle or title
            let displayName = m.subtitle || m.title;

            // Filter out Jan Schakowsky
            if (displayName.toLowerCase().includes('schakowsky')) {
                return;
            }

            const last_price = m.last_price || 0;
            const yes_bid = m.yes_bid || 0;
            const yes_ask = m.yes_ask || 0;
            const midpoint = (yes_bid + yes_ask) / 2;

            // Extract order book volume data
            const yes_bid_volume = m.yes_bid_size || 0;
            const no_bid_volume = m.no_bid_size || 0;

            if (last_price > 0 || midpoint > 0) {
                const key = normalizeCandidate(displayName);
                const localMid = midpoint;

                // Liquidity-weighted price based on last trade position within spread
                const spread = yes_ask - yes_bid;
                let kalshiLiquidity = localMid;

                console.log(`${displayName} RAW DATA: yes_bid=${yes_bid}, yes_ask=${yes_ask}, last=${last_price}, spread=${spread.toFixed(2)}, mid=${localMid.toFixed(1)}`);

                if (spread > 0 && last_price > 0) {
                    // Liquidity weighting: where did the last trade occur within the spread?
                    // - Last price near ask (1.0) → buyers aggressive → shift up
                    // - Last price near bid (0.0) → sellers aggressive → shift down
                    // - Last price at mid (0.5) → balanced → no shift

                    // Position in spread: 0 = at bid, 0.5 = at mid, 1 = at ask
                    const positionInSpread = Math.max(0, Math.min(1, (last_price - yes_bid) / spread));

                    // Offset from midpoint: -0.5 to +0.5
                    const offsetFromMid = positionInSpread - 0.5;

                    // Spread dampening: wider spreads = less confidence in the signal
                    // At 0pp spread: factor = 1.0 (full shift potential)
                    // At 10pp spread: factor = 0.2 (heavily dampened)
                    const spreadFactor = Math.max(0.2, 1 - (spread / 10) * 0.8);

                    // Calculate shift: scale by 6 (so ±0.5 offset → ±3pp max), apply dampening
                    const rawShift = offsetFromMid * 6 * spreadFactor;

                    // Cap at ±3 percentage points
                    const priceShift = Math.max(-3, Math.min(3, rawShift));

                    kalshiLiquidity = Math.max(0, Math.min(100, localMid + priceShift));

                    console.log(`${displayName} liquidity: pos_in_spread=${positionInSpread.toFixed(2)}, offset=${offsetFromMid.toFixed(2)}, spread_factor=${spreadFactor.toFixed(2)}, shift=${priceShift.toFixed(2)}, result=${kalshiLiquidity.toFixed(1)}`);
                } else {
                    console.log(`${displayName} NO spread/last data - using midpoint ${localMid}`);
                }

                kalshiData[key] = {
                    displayName: displayName,
                    last_price: last_price,
                    yes_bid: yes_bid,
                    yes_ask: yes_ask,
                    midpoint: midpoint,
                    yes_bid_volume: yes_bid_volume,
                    no_bid_volume: no_bid_volume,
                    kalshiLiquidity: kalshiLiquidity
                };

                kalshiList.push({
                    name: cleanCandidateName(displayName),
                    probability: Math.round(last_price * 10) / 10
                });
            }
        });

        kalshiList.sort((a, b) => b.probability - a.probability);
        renderKalshiExpanded(kalshiList);

        console.log('Kalshi candidates processed:', kalshiList);
        console.log('Kalshi data object:', kalshiData);

        // Update timestamp
        document.getElementById('kalshiUpdated').textContent = `Live data - ${new Date().toLocaleTimeString()}`;

        // Calculate aggregate if both Manifold and Kalshi data are ready
        if (Object.keys(manifoldData).length > 0 && Object.keys(kalshiData).length > 0) {
            console.log('Recalculating aggregate with updated Kalshi data');
            console.log('Manifold keys:', Object.keys(manifoldData));
            console.log('Kalshi keys:', Object.keys(kalshiData));
            await calculateAggregate();
        } else {
            console.log('Waiting for both data sources. Manifold:', Object.keys(manifoldData).length, 'Kalshi:', Object.keys(kalshiData).length);
        }

    } catch (error) {
        console.error('Error fetching Kalshi data:', error);
        document.getElementById('kalshiPreview').textContent = 'Error loading';
        document.getElementById('kalshiCandidates').innerHTML = '<p style="color: var(--text-secondary);">Error loading Kalshi data</p>';
    }
}

function renderKalshiExpanded(candidates) {
    if (candidates.length === 0) {
        document.getElementById('kalshiPreview').textContent = 'No data';
        return;
    }

    // Update preview - use last name only
    const top = candidates[0];
    const nameParts = top.name.split(' ');
    const topName = nameParts[nameParts.length - 1]; // Get last name
    document.getElementById('kalshiPreview').textContent = `Top: ${topName} ${Math.round(top.probability)}%`;

    // Update expanded list
    const container = document.getElementById('kalshiCandidates');
    container.innerHTML = candidates.map(c => `
        <div class="market-candidate">
            <span class="candidate-name">${c.name}</span>
            <span class="candidate-odds">${c.probability}%</span>
        </div>
    `).join('');
}

function getPollingInterval() {
    const electionDay = new Date('2026-03-17');
    const today = new Date();
    const millisecondsUntilElection = electionDay - today;
    const daysUntilElection = millisecondsUntilElection / (1000 * 60 * 60 * 24);

    // Election day: poll every 1 minute
    if (daysUntilElection <= 0 && daysUntilElection > -1) {
        return 1 * 60 * 1000; // 1 minute
    }
    // Last 3 days before election: poll every 1 minute
    else if (daysUntilElection <= 3) {
        return 1 * 60 * 1000; // 1 minute
    }
    // Default: poll every 3 minutes
    else {
        return 3 * 60 * 1000; // 3 minutes
    }
}

function setupPolling() {
    // Initial fetch
    fetchManifoldData();
    fetchKalshiData();

    // Set up interval polling with dynamic intervals
    let currentInterval = null;

    function setupNextPoll() {
        const interval = getPollingInterval();

        if (currentInterval) {
            clearInterval(currentInterval);
        }

        currentInterval = setInterval(() => {
            fetchManifoldData();
            fetchKalshiData();
            setupNextPoll(); // Re-check interval after each poll in case it changed
        }, interval);

        console.log(`Polling set to every ${interval / 1000 / 60} minute(s)`);
    }

    setupNextPoll();
}

document.addEventListener('DOMContentLoaded', () => {
    const navbar = document.querySelector('.navbar');
    const footer = document.querySelector('.footer');
    if (navbar) navbar.style.display = 'none';
    if (footer) footer.style.display = 'none';

    // Set up chart toggle buttons
    document.querySelectorAll('.toggle-btn').forEach(btn => {
        btn.addEventListener('click', async (e) => {
            // Update button states
            document.querySelectorAll('.toggle-btn').forEach(b => b.classList.remove('active'));
            e.target.classList.add('active');

            currentChartPeriod = e.target.dataset.period;

            // Render chart with the selected period (handles both 30d and 1h)
            await renderMarketTrendChart(candidatesData);
        });
    });

    setupPolling();
});
</script>
{% endblock %}
