{% extends "base.html" %}

{% block title %}Prediction Markets - IL9Cast{% endblock %}

{% block content %}
<div class="inner-page markets-page">
    <nav class="inner-nav">
        <a href="/" class="back-link">IL9Cast</a>
        <div class="inner-nav-links">
            <a href="/odds">The Model</a>
            <a href="/markets" class="active">Markets</a>
            <a href="/fundraising">Fundraising</a>
            <a href="/methodology">Methodology</a>
            <a href="/about">About</a>
        </div>
    </nav>

    <div class="inner-content">
        <h1 class="inner-title">Prediction Markets</h1>
        <p class="page-subtitle">Aggregated odds from Manifold Markets and Kalshi</p>

        <!-- Big Blue Bars Display -->
        <section class="big-bars-display" id="bigBarsDisplay">
            <div class="bar-candidate">
                <div class="bar-header">
                    <span class="bar-name">Loading...</span>
                    <span class="bar-percent">--</span>
                </div>
                <div class="bar-container">
                    <div class="bar-fill" style="width: 0%;"></div>
                </div>
            </div>
        </section>

        <!-- Market Trends Chart -->
        <section class="market-chart-section">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
                <h2 style="margin: 0;">Market Trends</h2>
                <div class="chart-toggle" id="chartToggle">
                    <button class="toggle-btn" data-period="1d">1 Day</button>
                    <button class="toggle-btn active" data-period="7d">7 Days</button>
                    <button class="toggle-btn" data-period="all">All Time</button>
                </div>
            </div>
            <div class="chart-wrapper">
                <canvas id="marketTrendChart"></canvas>
            </div>
        </section>

        <!-- Aggregation Methodology -->
        <section class="weights-explainer">
            <h2>Aggregation Methodology</h2>
            <div class="weights-list">
                <div class="weight-row">
                    <span class="weight-title">Manifold Markets</span>
                    <span class="weight-percentage">40%</span>
                </div>
                <div class="weight-row">
                    <span class="weight-title">Kalshi (Last Price)</span>
                    <span class="weight-percentage">42%</span>
                </div>
                <div class="weight-row">
                    <span class="weight-title">Kalshi (Midpoint)</span>
                    <span class="weight-percentage">12%</span>
                </div>
                <div class="weight-row">
                    <span class="weight-title">Kalshi (Liquidity)</span>
                    <span class="weight-percentage">6%</span>
                </div>
            </div>
            <div class="formula">
                <strong>Formula:</strong> Aggregate = (0.40 × Manifold) + (0.42 × Last) + (0.12 × Midpoint) + (0.06 × Liquidity)
                <div style="margin-top: 0.8rem; font-size: 0.85rem; opacity: 0.8;">
                    Soft Normalization (30% strength) applied to prevent drift while preserving market values.
                </div>
            </div>
        </section>

        <!-- Market Sources -->
        <section class="additional-markets">
            <h2>Market Sources</h2>

            <div class="expandable-market" id="manifoldMarket">
                <button class="expand-toggle" onclick="toggleMarket('manifoldMarket')">
                    <span class="market-name">Manifold Markets</span>
                    <span class="market-preview" id="manifoldPreview">Loading...</span>
                    <span class="expand-icon">+</span>
                </button>
                <div class="expand-content">
                    <div class="market-candidates" id="manifoldCandidates">
                        <div class="market-candidate">
                            <span class="candidate-name">Loading...</span>
                            <span class="candidate-odds">--</span>
                        </div>
                    </div>
                    <div class="market-footer">
                        <span class="last-updated" id="manifoldUpdated">Fetching data...</span>
                        <a href="https://manifold.markets/JeromeHPowell/who-will-win-the-democratic-primary-RZdcps6dL9" target="_blank" class="market-link">View on Manifold →</a>
                    </div>
                </div>
            </div>

            <div class="expandable-market" id="kalshiMarket">
                <button class="expand-toggle" onclick="toggleMarket('kalshiMarket')">
                    <span class="market-name">Kalshi</span>
                    <span class="market-preview" id="kalshiPreview">Loading...</span>
                    <span class="expand-icon">+</span>
                </button>
                <div class="expand-content">
                    <div class="market-candidates" id="kalshiCandidates">
                        <div class="market-candidate">
                            <span class="candidate-name">Loading...</span>
                            <span class="candidate-odds">--</span>
                        </div>
                    </div>
                    <div class="market-footer">
                        <span class="last-updated" id="kalshiUpdated">Fetching data...</span>
                        <a href="https://kalshi.com/markets/kxil9d/il-9-democratic-primary/kxil9d-26" target="_blank" class="market-link">View on Kalshi →</a>
                    </div>
                </div>
            </div>
        </section>

        <!-- Download Data Section -->
        <section class="download-data-section">
            <h2>Download Historical Data</h2>
            <p class="download-description">Download the complete historical snapshot data (JSONL format)</p>
            <a href="/api/download/snapshots" class="download-button" download>
                <span class="download-icon">⬇</span>
                Download Data (JSONL)
            </a>
        </section>

        <!-- Data Gap Disclaimer -->
        <div class="data-disclaimer">
            *Data gaps present on Jan 28-29 due to cloud provider (Railway) maintenance.
        </div>

    </div>
</div>

<style>
.big-bars-display {
    margin: 2.5rem 0;
}

.bar-candidate {
    margin-bottom: 1.5rem;
}

.bar-header {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    margin-bottom: 0.5rem;
}

.bar-name {
    font-size: 1.1rem;
    font-weight: 600;
    color: var(--text-primary);
}

.bar-percent {
    font-size: 1.8rem;
    font-weight: 700;
    color: var(--accent-primary);
    font-family: 'Times New Roman', Times, serif;
}

.bar-container {
    width: 100%;
    height: 48px;
    background-color: rgba(255, 255, 255, 0.05);
    border-radius: 4px;
    overflow: hidden;
    border: 1px solid var(--border-color);
}

.bar-fill {
    height: 100%;
    background: linear-gradient(90deg, #0066CC 0%, #0088FF 100%);
    transition: width 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    border-radius: 3px;
}

.weights-explainer {
    background: var(--bg-card);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 2rem;
    margin-bottom: 2.5rem;
    margin-top: 2.5rem;
}

.weights-explainer h2 {
    margin-bottom: 1rem;
    font-size: 1.3rem;
    color: var(--text-primary);
}

.weights-list {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    margin-bottom: 1.5rem;
    padding: 1rem;
    background: rgba(0, 102, 204, 0.08);
    border: 1px solid rgba(0, 102, 204, 0.2);
    border-radius: 6px;
}

.weight-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.5rem 0;
}

.weight-title {
    font-size: 0.95rem;
    color: var(--text-primary);
    font-weight: 500;
}

.weight-percentage {
    font-size: 1.1rem;
    font-weight: 700;
    font-family: 'Times New Roman', Times, serif;
    color: var(--accent-primary);
    min-width: 50px;
    text-align: right;
}

.formula {
    font-family: 'Courier New', monospace;
    font-size: 0.9rem;
    color: var(--text-primary);
    padding: 1rem;
    background: rgba(0, 0, 0, 0.2);
    border-left: 3px solid var(--accent-primary);
    border-radius: 4px;
    margin: 0;
}

.market-chart-section {
    margin-top: 2.5rem;
    padding: 2rem;
    background: var(--bg-card);
    border: 1px solid var(--border-color);
    border-radius: 12px;
}

.market-chart-section h2 {
    margin-bottom: 1.5rem;
    font-size: 1.3rem;
    color: var(--text-primary);
}

.market-chart-section .chart-wrapper {
    height: 320px;
    position: relative;
    padding: 0.5rem 0;
}

.additional-markets {
    margin-top: 2.5rem;
}

.additional-markets h2 {
    margin-bottom: 1rem;
    font-size: 1.3rem;
    color: var(--text-primary);
}

.expandable-market {
    margin-bottom: 1rem;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    overflow: hidden;
    background: var(--bg-card);
}

.expand-toggle {
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 1.25rem 1.5rem;
    background: transparent;
    border: none;
    cursor: pointer;
    color: var(--text-primary);
    font-family: inherit;
    font-size: 1rem;
    transition: background 0.2s ease;
    gap: 2rem;
}

.expand-toggle:hover {
    background: rgba(255, 255, 255, 0.03);
}

.market-name {
    font-weight: 600;
    font-size: 0.95rem;
    min-width: 140px;
}

.market-preview {
    color: var(--text-secondary);
    font-size: 0.9rem;
    flex: 1;
    text-align: left;
}

.expand-icon {
    font-size: 1.5rem;
    color: var(--accent-primary);
    transition: transform 0.3s ease;
}

.expandable-market.open .expand-icon {
    transform: rotate(45deg);
}

.expand-content {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.3s ease, padding 0.3s ease;
    padding: 0 1.5rem;
}

.expandable-market.open .expand-content {
    max-height: 500px;
    padding: 1rem 1.5rem 1.5rem;
    border-top: 1px solid var(--border-color);
}

.expand-content .market-candidates {
    margin-bottom: 1rem;
}

.expand-content .market-candidate {
    display: flex;
    justify-content: space-between;
    padding: 0.6rem 0;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
}

.expand-content .market-candidate:last-child {
    border-bottom: none;
}

.expand-content .market-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding-top: 1rem;
    border-top: 1px solid var(--border-color);
    margin-top: 0.5rem;
}

.market-link {
    color: var(--accent-primary);
    text-decoration: none;
    font-size: 0.9rem;
}

.market-link:hover {
    text-decoration: underline;
}

.chart-toggle {
    display: flex;
    gap: 0.25rem;
    background: rgba(0, 0, 0, 0.3);
    padding: 4px;
    border-radius: 8px;
    border: 1px solid rgba(255, 255, 255, 0.06);
}

.toggle-btn {
    padding: 0.5rem 1.25rem;
    background: transparent;
    border: none;
    color: rgba(255, 255, 255, 0.5);
    border-radius: 6px;
    cursor: pointer;
    font-size: 0.85rem;
    font-weight: 500;
    transition: all 0.25s ease;
}

.toggle-btn:hover {
    color: rgba(255, 255, 255, 0.8);
    background: rgba(255, 255, 255, 0.05);
}

.toggle-btn.active {
    background: rgba(0, 102, 204, 0.3);
    color: #0088FF;
    box-shadow: 0 0 12px rgba(0, 102, 204, 0.3);
}

.download-data-section {
    margin-top: 2.5rem;
    padding: 2rem;
    background: var(--bg-card);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    text-align: center;
}

.download-data-section h2 {
    margin-bottom: 0.5rem;
    font-size: 1.3rem;
    color: var(--text-primary);
}

.download-description {
    margin-bottom: 1.5rem;
    color: var(--text-secondary);
    font-size: 0.95rem;
}

.download-button {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem 1.5rem;
    background: linear-gradient(135deg, #0066CC 0%, #0088FF 100%);
    color: white;
    text-decoration: none;
    border-radius: 6px;
    font-weight: 600;
    font-size: 1rem;
    transition: all 0.3s ease;
    border: none;
    cursor: pointer;
}

.download-button:hover {
    background: linear-gradient(135deg, #0055AA 0%, #0077EE 100%);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 102, 204, 0.3);
}

.download-icon {
    font-size: 1.2rem;
}

.data-disclaimer {
    margin-top: 2rem;
    padding: 1rem;
    font-size: 0.85rem;
    color: var(--text-secondary);
    text-align: right;
    font-style: italic;
    border-top: 1px solid var(--border-color);
}
</style>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
let marketChart = null;
let candidatesData = [];
let manifoldData = {};
let kalshiData = {};
let currentChartPeriod = '7d';

function toggleMarket(id) {
    const market = document.getElementById(id);
    market.classList.toggle('open');
}

function normalizeCandidate(name) {
    let cleaned = name.toLowerCase()
        .replace(/^wil\s+/i, '')
        .replace(/^will\s+/i, '')
        .replace(/\sbe\sthe\sdemocratic\snominee.*$/i, '')
        .replace(/\sfor\sil-9.*$/i, '')
        .replace(/\swin.*$/i, '')
        .replace(/dr\.\s+/i, '')
        .replace(/\?/g, '')
        .trim();

    const nameVariations = {
        'kat abughazaleh': 'kat abugazaleh',
    };

    if (nameVariations[cleaned]) {
        cleaned = nameVariations[cleaned];
    }

    return cleaned;
}

function cleanCandidateName(name) {
    return name
        .replace(/^wil\s+/i, '')
        .replace(/^will\s+/i, '')
        .replace(/\sbe\sthe\sdemocratic\snominee.*$/i, '')
        .replace(/\sfor\sil-9.*$/i, '')
        .replace(/\?/g, '')
        .trim();
}

async function calculateAggregate() {
    const aggregated = [];
    const allCandidates = new Set();
    Object.keys(manifoldData).forEach(name => allCandidates.add(name));
    Object.keys(kalshiData).forEach(name => allCandidates.add(name));

    allCandidates.forEach(candidateKey => {
        if (candidateKey.toLowerCase().includes('schakowsky')) {
            return;
        }

        const manifoldProb = manifoldData[candidateKey]?.probability || 0;
        const kalshiInfo = kalshiData[candidateKey] || {};
        const kalshiLast = kalshiInfo.last_price || 0;
        const kalshiMid = kalshiInfo.midpoint || 0;
        const kalshiLiq = kalshiInfo.kalshiLiquidity || kalshiMid;

        const hasKalshi = kalshiLast > 0 || kalshiMid > 0;

        let aggregate;
        if (hasKalshi) {
            aggregate = (0.40 * manifoldProb) + (0.42 * kalshiLast) + (0.12 * kalshiMid) + (0.06 * kalshiLiq);
        } else {
            aggregate = manifoldProb;
        }

        if (aggregate > 0 || manifoldProb > 0) {
            const displayName = manifoldData[candidateKey]?.displayName || kalshiInfo.displayName || candidateKey;
            const cleanName = cleanCandidateName(displayName);

            aggregated.push({
                name: cleanName,
                probability: aggregate,
                hasKalshi: hasKalshi
            });
        }
    });

    // Soft normalization (30% strength)
    const total = aggregated.reduce((sum, c) => sum + c.probability, 0);
    if (total > 0) {
        aggregated.forEach(c => {
            const fullyNormalized = (c.probability / total) * 100;
            const adjustment = fullyNormalized - c.probability;
            c.probability = c.probability + (adjustment * 0.30);
        });
    }

    aggregated.sort((a, b) => b.probability - a.probability);
    candidatesData = aggregated;

    await saveSnapshot(aggregated);
    renderBigBars(aggregated);
    await renderMarketTrendChart(aggregated);
}

async function saveSnapshot(candidates) {
    try {
        const snapshot = {
            candidates: candidates.map(c => ({
                name: c.name,
                probability: Math.round(c.probability * 10) / 10,
                hasKalshi: c.hasKalshi
            }))
        };

        await fetch('/api/snapshot', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(snapshot)
        });
    } catch (error) {
        console.error('Error saving snapshot:', error);
    }
}

function renderBigBars(candidates) {
    const container = document.getElementById('bigBarsDisplay');
    container.innerHTML = candidates.map((c, idx) => {
        const asterisk = !c.hasKalshi ? '*' : '';
        const barColor = `hsl(${210 - idx * 15}, 100%, ${50 - idx * 3}%)`;

        return `
        <div class="bar-candidate">
            <div class="bar-header">
                <span class="bar-name">${c.name}${asterisk}</span>
                <span class="bar-percent">${Math.round(c.probability)}%</span>
            </div>
            <div class="bar-container">
                <div class="bar-fill" style="width: ${c.probability}%; background: ${barColor};"></div>
            </div>
        </div>
        `;
    }).join('');
}

async function fetchManifoldData() {
    try {
        const response = await fetch('/api/manifold');
        const data = await response.json();

        if (data.error) throw new Error(data.error);

        const answers = data.answers || [];
        const manifoldList = answers
            .map(a => ({
                name: a.text,
                probability: Math.round(a.probability * 1000) / 10
            }))
            .filter(a => a.name !== 'Other' && !a.name.toLowerCase().includes('schakowsky'))
            .sort((a, b) => b.probability - a.probability);

        manifoldList.forEach(c => {
            const key = normalizeCandidate(c.name);
            manifoldData[key] = {
                displayName: c.name,
                probability: c.probability
            };
        });

        renderManifoldExpanded(manifoldList);

        const updated = new Date(data.lastBetTime || data.lastUpdatedTime);
        document.getElementById('manifoldUpdated').textContent = `Updated ${updated.toLocaleString()}`;

        if (Object.keys(kalshiData).length > 0 && Object.keys(manifoldData).length > 0) {
            await calculateAggregate();
        }
    } catch (error) {
        console.error('Error fetching Manifold data:', error);
        document.getElementById('bigBarsDisplay').innerHTML = '<p style="color: var(--text-secondary);">Error loading market data</p>';
    }
}

function renderManifoldExpanded(candidates) {
    const top = candidates[0];
    document.getElementById('manifoldPreview').textContent = `Top: ${top.name.split(' ').pop()} ${Math.round(top.probability)}%`;

    const container = document.getElementById('manifoldCandidates');
    container.innerHTML = candidates.map(c => `
        <div class="market-candidate">
            <span class="candidate-name">${c.name}</span>
            <span class="candidate-odds">${c.probability}%</span>
        </div>
    `).join('');
}

async function fetchKalshiData() {
    try {
        const response = await fetch('/api/kalshi');
        const data = await response.json();

        if (data.error) throw new Error(data.error);

        const markets = data.markets || [];
        const kalshiList = [];

        markets.forEach(m => {
            let displayName = m.subtitle || m.title;
            if (displayName.toLowerCase().includes('schakowsky')) return;

            const last_price = m.last_price || 0;
            const yes_bid = m.yes_bid || 0;
            const yes_ask = m.yes_ask || 0;
            const midpoint = (yes_bid + yes_ask) / 2;

            if (last_price > 0 || midpoint > 0) {
                const key = normalizeCandidate(displayName);
                const spread = yes_ask - yes_bid;
                let kalshiLiquidity = midpoint;

                if (spread > 0 && last_price > 0) {
                    const positionInSpread = Math.max(0, Math.min(1, (last_price - yes_bid) / spread));
                    const offsetFromMid = positionInSpread - 0.5;
                    const spreadFactor = Math.max(0.2, 1 - (spread / 10) * 0.8);
                    const priceShift = Math.max(-3, Math.min(3, offsetFromMid * 6 * spreadFactor));
                    kalshiLiquidity = Math.max(0, Math.min(100, midpoint + priceShift));
                }

                kalshiData[key] = {
                    displayName: displayName,
                    last_price: last_price,
                    yes_bid: yes_bid,
                    yes_ask: yes_ask,
                    midpoint: midpoint,
                    kalshiLiquidity: kalshiLiquidity
                };

                kalshiList.push({
                    name: cleanCandidateName(displayName),
                    probability: Math.round(last_price * 10) / 10
                });
            }
        });

        kalshiList.sort((a, b) => b.probability - a.probability);
        renderKalshiExpanded(kalshiList);

        document.getElementById('kalshiUpdated').textContent = `Live data - ${new Date().toLocaleTimeString()}`;

        if (Object.keys(manifoldData).length > 0 && Object.keys(kalshiData).length > 0) {
            await calculateAggregate();
        }
    } catch (error) {
        console.error('Error fetching Kalshi data:', error);
        document.getElementById('kalshiPreview').textContent = 'Error loading';
    }
}

function renderKalshiExpanded(candidates) {
    if (candidates.length === 0) {
        document.getElementById('kalshiPreview').textContent = 'No data';
        return;
    }

    const top = candidates[0];
    const topName = top.name.split(' ').pop();
    document.getElementById('kalshiPreview').textContent = `Top: ${topName} ${Math.round(top.probability)}%`;

    const container = document.getElementById('kalshiCandidates');
    container.innerHTML = candidates.map(c => `
        <div class="market-candidate">
            <span class="candidate-name">${c.name}</span>
            <span class="candidate-odds">${c.probability}%</span>
        </div>
    `).join('');
}

function aggregateSnapshots(snapshots, period) {
    const buckets = {};

    snapshots.forEach(snapshot => {
        const ts = snapshot.timestamp;
        let date;
        if (ts.endsWith('Z')) {
            date = new Date(ts);
        } else {
            const [datePart, timePart] = ts.split('T');
            const [year, month, day] = datePart.split('-').map(Number);
            const [hour, min, sec] = (timePart || '00:00:00').split(':').map(n => parseInt(n));
            date = new Date(year, month - 1, day, hour, min, sec || 0);
        }

        let bucketKey;
        if (period === '1d') {
            const minutes = Math.floor(date.getMinutes() / 15) * 15;
            bucketKey = `${date.getFullYear()}-${String(date.getMonth()+1).padStart(2,'0')}-${String(date.getDate()).padStart(2,'0')}T${String(date.getHours()).padStart(2,'0')}:${String(minutes).padStart(2,'0')}:00`;
        } else if (period === 'all') {
            bucketKey = `${date.getFullYear()}-${String(date.getMonth()+1).padStart(2,'0')}-${String(date.getDate()).padStart(2,'0')}T12:00:00`;
        } else {
            bucketKey = `${date.getFullYear()}-${String(date.getMonth()+1).padStart(2,'0')}-${String(date.getDate()).padStart(2,'0')}T${String(date.getHours()).padStart(2,'0')}:00:00`;
        }

        if (!buckets[bucketKey]) buckets[bucketKey] = [];
        buckets[bucketKey].push(snapshot);
    });

    const aggregated = Object.keys(buckets).sort().map(bucketKey => {
        const snapshotsInBucket = buckets[bucketKey];
        const allCandidates = new Set();
        snapshotsInBucket.forEach(s => s.candidates.forEach(c => allCandidates.add(c.name)));

        const candidateAverages = Array.from(allCandidates).map(name => {
            const probs = snapshotsInBucket
                .map(s => s.candidates.find(c => c.name === name)?.probability)
                .filter(p => p !== undefined);

            const avgProb = probs.reduce((sum, p) => sum + p, 0) / probs.length;
            const hasKalshi = snapshotsInBucket.some(s =>
                s.candidates.find(c => c.name === name)?.hasKalshi
            );

            return { name, probability: avgProb, hasKalshi };
        });

        return { timestamp: bucketKey, candidates: candidateAverages };
    });

    return aggregated;
}

async function renderMarketTrendChart(candidates) {
    const ctx = document.getElementById('marketTrendChart').getContext('2d');

    let snapshots = [];
    try {
        const response = await fetch('/api/snapshots');
        snapshots = await response.json();
    } catch (error) {
        console.error('Error fetching historical snapshots:', error);
    }

    if (snapshots.length < 2) {
        if (marketChart) marketChart.destroy();
        ctx.font = '14px Arial';
        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.textAlign = 'center';
        ctx.fillText('Collecting historical data... Check back soon for trend charts.', ctx.canvas.width / 2, ctx.canvas.height / 2);
        return;
    }

    const now = new Date();
    const period = currentChartPeriod || '7d';
    let filteredSnapshots = snapshots;

    if (period !== 'all') {
        let cutoffTime;
        if (period === '1d') {
            cutoffTime = new Date(now - 24 * 60 * 60 * 1000);
        } else {
            cutoffTime = new Date(now - 7 * 24 * 60 * 60 * 1000);
        }

        filteredSnapshots = snapshots.filter(s => {
            const ts = s.timestamp;
            let snapshotDate;
            if (ts.endsWith('Z')) {
                snapshotDate = new Date(ts);
            } else {
                const [datePart, timePart] = ts.split('T');
                const [year, month, day] = datePart.split('-').map(Number);
                const [hour, min, sec] = (timePart || '00:00:00').split(':').map(n => parseInt(n));
                snapshotDate = new Date(year, month - 1, day, hour, min, sec || 0);
            }
            return snapshotDate > cutoffTime;
        });

        const MIN_DATA_POINTS = 10;
        if (filteredSnapshots.length < MIN_DATA_POINTS && snapshots.length >= MIN_DATA_POINTS) {
            filteredSnapshots = snapshots.slice(-MIN_DATA_POINTS);
        }
    }

    const aggregatedSnapshots = aggregateSnapshots(filteredSnapshots, period);

    const labels = aggregatedSnapshots.map((s) => {
        const ts = s.timestamp;
        let date;
        if (ts.endsWith('Z')) {
            date = new Date(ts);
        } else {
            const [datePart, timePart] = ts.split('T');
            const [year, month, day] = datePart.split('-').map(Number);
            const [hour, min, sec] = (timePart || '00:00:00').split(':').map(n => parseInt(n));
            date = new Date(year, month - 1, day, hour, min, sec || 0);
        }

        if (period === '1d') {
            return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
        } else if (period === 'all') {
            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        } else {
            return date.toLocaleString('en-US', { month: 'short', day: 'numeric', hour: 'numeric', hour12: true });
        }
    });

    const colors = ['#0066CC', '#FF6B35', '#6D904F', '#8B8B8B', '#E5AE38', '#810F7C'];

    const topCandidates = candidates.slice(0, 6);
    const datasets = topCandidates.map((c, idx) => {
        const data = aggregatedSnapshots.map(snapshot => {
            const candidateData = snapshot.candidates.find(sc => sc.name === c.name);
            return candidateData ? candidateData.probability : null;
        });

        return {
            label: c.name,
            data: data,
            borderColor: colors[idx],
            backgroundColor: 'transparent',
            borderWidth: 2.5,
            tension: 0,
            fill: false,
            pointRadius: 2,
            pointHoverRadius: 4,
            pointBackgroundColor: colors[idx],
            pointBorderColor: '#fff',
            pointBorderWidth: 1,
            spanGaps: true
        };
    });

    if (marketChart) marketChart.destroy();

    marketChart = new Chart(ctx, {
        type: 'line',
        data: { labels, datasets },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: { mode: 'index', intersect: false },
            plugins: {
                legend: {
                    position: 'bottom',
                    labels: {
                        boxWidth: 12,
                        boxHeight: 12,
                        padding: 15,
                        color: 'rgba(255, 255, 255, 0.8)',
                        font: { size: 12 }
                    }
                },
                tooltip: {
                    backgroundColor: 'rgba(0, 0, 0, 0.9)',
                    titleColor: '#fff',
                    bodyColor: '#fff',
                    borderColor: 'rgba(255, 255, 255, 0.1)',
                    borderWidth: 1,
                    padding: 10,
                    callbacks: {
                        label: (context) => `${context.dataset.label}: ${context.parsed.y?.toFixed(1) || '--'}%`
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    max: 100,
                    ticks: {
                        stepSize: 10,
                        callback: (value) => value + '%',
                        color: 'rgba(255, 255, 255, 0.6)',
                        font: { size: 11 }
                    },
                    grid: { color: 'rgba(255, 255, 255, 0.08)', drawBorder: false },
                    border: { display: false }
                },
                x: {
                    ticks: {
                        color: 'rgba(255, 255, 255, 0.6)',
                        maxTicksLimit: 10,
                        font: { size: 10 },
                        maxRotation: 45,
                        minRotation: 0
                    },
                    grid: { color: 'rgba(255, 255, 255, 0.05)', drawBorder: false },
                    border: { display: false }
                }
            }
        }
    });
}

function setupPolling() {
    fetchManifoldData();
    fetchKalshiData();

    setInterval(() => {
        fetchManifoldData();
        fetchKalshiData();
    }, 3 * 60 * 1000);
}

document.addEventListener('DOMContentLoaded', () => {
    const navbar = document.querySelector('.navbar');
    const footer = document.querySelector('.footer');
    if (navbar) navbar.style.display = 'none';
    if (footer) footer.style.display = 'none';

    document.querySelectorAll('.toggle-btn').forEach(btn => {
        btn.addEventListener('click', async (e) => {
            document.querySelectorAll('.toggle-btn').forEach(b => b.classList.remove('active'));
            e.target.classList.add('active');
            currentChartPeriod = e.target.dataset.period;
            await renderMarketTrendChart(candidatesData);
        });
    });

    setupPolling();
});
</script>
{% endblock %}
