<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="IL9Cast - Methodology">
    <title>Methodology - IL9Cast</title>
    <link rel="icon" type="image/svg+xml" href="{{ url_for('static', filename='favicon.svg') }}">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@400;500;600&family=Inter:wght@400;500;600&family=VT323&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='landing-style.css') }}">
</head>
<body class="dark-mode">
    <canvas id="grid-canvas"></canvas>

    <div class="site-content">
        <header>
            <a href="/" class="logo">IL9<span>Cast</span></a>
            <nav>
                <a href="/">Home</a>
                <a href="/markets">Markets</a>
                <a href="/odds">Model</a>
                <a href="/fundraising">Fundraising</a>
                <a href="/methodology" class="active">Methodology</a>
                <a href="/about">About</a>
                <a href="https://github.com/de-bayes/IL9" target="_blank" rel="noopener noreferrer" class="github-link" title="View on GitHub">GitHub</a>
            </nav>
        </header>

        <section class="hero">
            <h1>Methodology</h1>
            <p class="subtitle">How IL9Cast generates its forecasts</p>
        </section>

        <section class="methodology-content-page">

            <!-- FOLDOUT 1: Prediction Markets Aggregation -->
            <div class="method-foldout" id="foldout-pm">
                <button class="foldout-trigger" onclick="toggleFoldout('pm')">
                    <div class="foldout-trigger-left">
                        <span class="foldout-icon" id="foldout-icon-pm"></span>
                        <div>
                            <h2>Prediction Markets Aggregation</h2>
                            <p class="foldout-desc">40% Manifold + 60% Kalshi weighted formula</p>
                        </div>
                    </div>
                    <span class="foldout-arrow" id="foldout-arrow-pm">+</span>
                </button>
                <div class="foldout-body" id="foldout-body-pm">
                    <div class="foldout-inner">
                        <p>The <a href="/markets">Markets page</a> aggregates real-time probabilities from two major prediction markets: <strong>Manifold Markets</strong> (community-driven) and <strong>Kalshi</strong> (real-money exchange). This provides a live, crowd-sourced forecast updated automatically as new trades occur.</p>

                        <h3>Overall Weighting: 40% Manifold + 60% Kalshi</h3>

                        <p><strong>Manifold Markets (40% weight):</strong></p>
                        <ul class="method-list">
                            <li>Community prediction market using play money</li>
                            <li>Lower barrier to entry, broader participation</li>
                            <li>Captures general consensus and casual forecasters</li>
                            <li>Uses an Automated Market Maker (AMM) for price discovery</li>
                            <li>Good for long-term sentiment, less susceptible to short-term noise</li>
                        </ul>

                        <p><strong>Kalshi (60% weight):</strong></p>
                        <ul class="method-list">
                            <li>Real-money exchange with cash-settled contracts</li>
                            <li>Higher barrier to entry, attracts serious forecasters with skin in the game</li>
                            <li>Reflects genuine conviction (money is at risk)</li>
                            <li>Traditional order book exchange (bid/ask spread pricing)</li>
                        </ul>

                        <h3>Kalshi Component Breakdown (60% total weight)</h3>

                        <p>Within Kalshi's 60% weight, we use three price signals:</p>

                        <p><strong>1. Last Price (42% overall = 70% of Kalshi's 60%)</strong></p>
                        <ul class="method-list">
                            <li>The most recent completed trade price</li>
                            <li>Reflects real money execution and recent market sentiment</li>
                            <li>Given highest weight because it shows actual conviction backed by capital</li>
                            <li>Most responsive to new information and recent trades</li>
                        </ul>

                        <p><strong>2. Midpoint (12% overall = 20% of Kalshi's 60%)</strong></p>
                        <ul class="method-list">
                            <li>Average of the current best bid and best ask prices: (bid + ask) / 2</li>
                            <li>Represents the fair value between buyers and sellers right now</li>
                            <li>Includes current order book state but not yet executed</li>
                            <li>Smooths out last trade anomalies or outliers</li>
                        </ul>

                        <p><strong>Thin-Market Fallback (Midpoint &amp; Liquidity)</strong></p>
                        <p>When a candidate has <strong>no yes-side bids</strong> (yes_bid = 0), the standard midpoint formula (yes_bid + yes_ask) / 2 produces a meaningless number — it averages zero against the ask, massively inflating the result. In these cases, both the Midpoint and Liquidity-Weighted components fall back to the candidate's <strong>last trade price</strong> instead.</p>
                        <p><strong>Example — Mike Simmons:</strong> Simmons has virtually no buy-side interest on Kalshi. His order book might show yes_bid = 0, yes_ask = 19, last_price = 1. Without the fallback, the midpoint formula would compute (0 + 19) / 2 = 9.5%, and the liquidity-weighted price would land around 9.0% — suggesting nearly 10% support for a candidate trading at 1 cent. With the fallback, both Midpoint and Liquidity correctly report 1%, matching his actual last trade. The spread-based liquidity adjustment is also skipped entirely because there is no real two-sided market to analyze.</p>

                        <p><strong>3. Liquidity-Weighted Price (6% overall = 10% of Kalshi's 60%)</strong></p>
                        <ul class="method-list">
                            <li><strong>Purpose:</strong> Captures buying vs selling pressure by analyzing where the last trade occurred within the bid-ask spread</li>
                            <li><strong>Why only Kalshi?</strong> Kalshi uses a traditional order book exchange where buyers and sellers post bids and asks. Manifold uses an Automated Market Maker (AMM) that algorithmically sets prices, so order book analysis doesn't apply</li>
                            <li><strong>How it works:</strong> Calculate position in spread = (Last Price - Bid) / (Ask - Bid). Position of 0.0 = traded at bid (sellers aggressive), 0.5 = at midpoint (balanced), 1.0 = at ask (buyers aggressive)</li>
                            <li><strong>Spread dampening:</strong> Wider spreads reduce the adjustment because they indicate less confidence. At 0pp spread: factor = 1.0 (full shift potential). At 10pp spread: factor = 0.2 (heavily dampened)</li>
                            <li><strong>Example:</strong> Bid=60, Ask=68, Last=66, Mid=64, Spread=8. Position = (66-60)/8 = 0.75 (near ask). Offset = 0.75 - 0.5 = +0.25. Dampening = 1 - (8/10)×0.8 = 0.36. Shift = 0.25 × 6 × 0.36 = +0.54pp. Result = 64 + 0.54 = 64.5% (buyers showed aggression)</li>
                            <li>Caps shift at ±3 percentage points to avoid overreaction</li>
                        </ul>

                        <h3>The Complete Formula</h3>
                        <div class="formula-box">
                            Aggregate Probability = (0.40 × Manifold) + (0.42 × Kalshi Last Price) + (0.12 × Kalshi Midpoint) + (0.06 × Kalshi Liquidity-Weighted)
                        </div>

                        <h3>Soft Normalization (30% Strength)</h3>
                        <p>Final probabilities are lightly normalized to prevent excessive drift while preserving raw market values:</p>
                        <ul class="method-list">
                            <li>Candidates with no Kalshi market (marked with *) use 100% of their Manifold probability</li>
                            <li>Only 30% of the normalization adjustment is applied to each candidate</li>
                            <li>70% of the raw aggregated value is preserved</li>
                            <li>This keeps top candidates higher while preventing probabilities from summing to unrealistic totals</li>
                        </ul>

                        <h3>Chart Smoothing</h3>
                        <p>To produce clean, readable trend lines, the chart pipeline applies multiple smoothing layers:</p>
                        <ul class="method-list">
                            <li><strong>Spike dampening:</strong> Per-candidate probability changes are capped at ±3 percentage points per 3-minute collection interval, preventing sudden jumps from thin-market trades or API glitches</li>
                            <li><strong>Exponential Moving Average (EMA):</strong> Chart data is smoothed server-side with an EMA (alpha = 0.15) — each displayed point is 15% new value + 85% previous smoothed value</li>
                            <li><strong>RDP simplification:</strong> The Ramer-Douglas-Peucker algorithm reduces thousands of raw data points to ~200-400 visually significant points, removing redundant noise</li>
                            <li><strong>Monotone cubic interpolation:</strong> The frontend renders curves using monotone splines that prevent overshoot between data points</li>
                        </ul>

                        <h3>Update Frequency</h3>
                        <ul class="method-list">
                            <li><strong>Default:</strong> Every 3 minutes</li>
                            <li><strong>Final 3 days before election:</strong> Every 1 minute</li>
                            <li><strong>Election day:</strong> Every 1 minute</li>
                        </ul>

                        <p>Historical snapshots are saved with every update and aggregated hourly for clean trend visualization.</p>
                    </div>
                </div>
            </div>

            <!-- FOLDOUT 2: Forecast Model -->
            <div class="method-foldout" id="foldout-model">
                <button class="foldout-trigger" onclick="toggleFoldout('model')">
                    <div class="foldout-trigger-left">
                        <span class="foldout-icon" id="foldout-icon-model"></span>
                        <div>
                            <h2>Forecast Model</h2>
                            <p class="foldout-desc">Multi-factor probabilistic model</p>
                        </div>
                    </div>
                    <span class="foldout-arrow" id="foldout-arrow-model">+</span>
                </button>
                <div class="foldout-body" id="foldout-body-model">
                    <div class="foldout-inner">
                        <div class="coming-soon-block">
                            <span class="coming-soon-icon">&#9881;</span>
                            <h3>Coming Soon</h3>
                            <p>The forecast model methodology will be published here once the model is live on the <a href="/odds">Model page</a>. It will incorporate prediction market data, fundraising metrics, endorsement signals, and historical primary patterns to generate win probabilities for each candidate.</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- FOLDOUT 3: Fundraising Analysis -->
            <div class="method-foldout" id="foldout-fundraising">
                <button class="foldout-trigger" onclick="toggleFoldout('fundraising')">
                    <div class="foldout-trigger-left">
                        <span class="foldout-icon" id="foldout-icon-fundraising"></span>
                        <div>
                            <h2>Fundraising Analysis</h2>
                            <p class="foldout-desc">FEC filing data and financial metrics</p>
                        </div>
                    </div>
                    <span class="foldout-arrow" id="foldout-arrow-fundraising">+</span>
                </button>
                <div class="foldout-body" id="foldout-body-fundraising">
                    <div class="foldout-inner">
                        <div class="coming-soon-block">
                            <span class="coming-soon-icon">&#9881;</span>
                            <h3>Coming Soon</h3>
                            <p>The fundraising methodology will be published here once FEC filing data is integrated on the <a href="/fundraising">Fundraising page</a>. It will detail how we source, normalize, and visualize campaign finance data including total raised, cash on hand, donor counts, and burn rates from Federal Election Commission filings.</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- FOLDOUT 4: Infrastructure & Technical Details -->
            <div class="method-foldout" id="foldout-infra">
                <button class="foldout-trigger" onclick="toggleFoldout('infra')">
                    <div class="foldout-trigger-left">
                        <span class="foldout-icon" id="foldout-icon-infra"></span>
                        <div>
                            <h2>Infrastructure &amp; Technical Stack</h2>
                            <p class="foldout-desc">Railway, JSONL storage, and the data pipeline under the hood</p>
                        </div>
                    </div>
                    <span class="foldout-arrow" id="foldout-arrow-infra">+</span>
                </button>
                <div class="foldout-body" id="foldout-body-infra">
                    <div class="foldout-inner">

                        <p>IL9Cast is a pretty lean operation — a single Python app running on Railway that does everything from fetching market data to serving the website. Here's how it all fits together.</p>

                        <h3>The Cloud Setup</h3>
                        <p>We run on <strong>Railway</strong>, which is a platform-as-a-service that deploys straight from GitHub. Every time we push code to the <code>main</code> branch, Railway automatically builds and deploys a new version using Nixpacks (their build system). The whole deploy cycle takes about 30 seconds.</p>
                        <p>The app runs behind <strong>Gunicorn</strong>, a production-grade Python WSGI server. We use the <code>--preload</code> flag, which is important — it loads the app once in memory before forking workers, so our background data collector only starts a single thread instead of duplicating itself across workers. Without that flag, you'd get multiple scrapers all writing to the same file at the same time, which is a recipe for corrupted data.</p>
                        <p>Here's the key configuration from <code>railway.toml</code>:</p>
                        <div class="formula-box" style="font-size: 0.95rem;">
                            startCommand = "gunicorn app:app --preload"<br>
                            healthcheckPath = "/"<br>
                            restartPolicyType = "ON_FAILURE"<br>
                            restartPolicyMaxRetries = 10
                        </div>
                        <p>That restart policy is our safety net. If the app crashes — maybe a dependency breaks, maybe Railway has a hiccup — it'll automatically restart up to 10 times before giving up. In practice, it almost never needs more than one.</p>

                        <h3>Persistent Storage (the tricky part)</h3>
                        <p>Railway containers are ephemeral by default — when the app redeploys, everything on the filesystem gets wiped. That's fine for code, but our historical data needs to survive between deploys. So we use a <strong>Railway persistent volume</strong> mounted at <code>/app/data</code>.</p>
                        <p>When the app boots up, it runs a path resolution function that checks, in order: <code>/data</code>, <code>/app/data</code>, then falls back to a local <code>data/</code> directory. This means the same code works on Railway (where the volume lives at <code>/app/data</code>) and on a developer's laptop (where it just uses the local folder). No environment variables, no conditional imports — just a directory check.</p>

                        <h3>Why JSONL (and not a database)</h3>
                        <p>You might wonder why we're storing data in a flat file instead of PostgreSQL or SQLite. Honestly? For our use case, JSONL is better.</p>
                        <p><strong>JSONL</strong> (JSON Lines) means one JSON object per line. Every 3 minutes, the scraper appends a single line to the file — that's it. No connection pools, no schema migrations, no ORM overhead. The file is human-readable (you can literally <code>tail</code> it to see the latest data), and if a line gets corrupted, every other line is still perfectly valid. Try saying that about a SQLite database after a partial write.</p>
                        <p>The append operation is actually a bit more careful than a simple file write:</p>
                        <ul class="method-list">
                            <li><strong>Write to a temp file first</strong> — the new snapshot goes to <code>historical_snapshots.jsonl.tmp</code></li>
                            <li><strong>Copy existing content + new line</strong> — both old data and the new snapshot get written to the temp file</li>
                            <li><strong>Atomic replace</strong> — <code>os.replace()</code> swaps the temp file into place in a single filesystem operation. If the app crashes mid-write, either the old file or the new file exists — never a half-written mess</li>
                        </ul>
                        <p>At 480 snapshots per day (~3 KB each), the file grows at roughly 1.4 MB/day. After a full election cycle, we're looking at maybe 70 MB total. That's nothing — your phone has thousands of times more storage. A database would be overkill here.</p>

                        <h3>The Data Collection Loop</h3>
                        <p>Every 3 minutes, a background thread wakes up and runs our <code>collect_market_data()</code> function. Here's what happens in those few hundred milliseconds:</p>
                        <ul class="method-list">
                            <li><strong>1. Fetch Manifold</strong> — HTTP GET to their public API. Returns JSON with each candidate's probability (0.0–1.0 scale, which we multiply by 100). Timeout: 10 seconds.</li>
                            <li><strong>2. Fetch Kalshi</strong> — HTTP GET to their trade API. Returns an array of markets, each with <code>last_price</code>, <code>yes_bid</code>, and <code>yes_ask</code>. Same 10-second timeout.</li>
                            <li><strong>3. Normalize names</strong> — Manifold calls her "Kat Abughazaleh" and Kalshi calls her "Katheryn Abughazaleh." We strip prefixes, suffixes, and known variations to get a canonical key for matching.</li>
                            <li><strong>4. Aggregate</strong> — Apply the 40/42/12/6 weighted formula (see the Markets Aggregation section above).</li>
                            <li><strong>5. Soft normalize</strong> — Nudge probabilities 30% toward summing to 100%, so the chart doesn't show the race at 130% or 80% total.</li>
                            <li><strong>6. Spike dampen</strong> — Compare to the previous snapshot. If any candidate moved more than ±3 percentage points, clamp the change. This prevents chart artifacts from thin-market Kalshi trades.</li>
                            <li><strong>7. Save</strong> — Atomically append to the JSONL file.</li>
                        </ul>
                        <p>If <em>both</em> APIs fail (say Manifold is down and Kalshi returns an error), we skip the snapshot entirely. Bad data is worse than missing data — the chart just won't have a point for that 3-minute window, and the gap detection handles it gracefully.</p>

                        <h3>The Scheduler Problem</h3>
                        <p>Running a background task alongside a web server sounds simple, but there's a subtle gotcha. When you run Flask locally, you get one process — easy. But Gunicorn can spawn multiple worker processes, and each one would try to run its own scheduler. That means two workers = two scrapers = double the data (and double the API calls).</p>
                        <p>We solve this two ways depending on the environment:</p>
                        <ul class="method-list">
                            <li><strong>Local development:</strong> Uses APScheduler's <code>BackgroundScheduler</code>, which runs the job in a background thread within the single Flask process.</li>
                            <li><strong>Production (Gunicorn):</strong> Detects Gunicorn via <code>sys.argv[0]</code> and instead spins up a plain <code>threading.Thread</code> in daemon mode. The <code>--preload</code> flag ensures this thread is created once in the master process before workers fork, so only one thread ever exists.</li>
                        </ul>

                        <h3>Chart Data Pipeline</h3>
                        <p>When you load the Markets page, your browser hits <code>/api/snapshots/chart?period=1d</code> (or <code>7d</code> or <code>all</code>). Here's what the server does before sending data back:</p>
                        <ul class="method-list">
                            <li><strong>Cache check</strong> — We keep a 60-second in-memory cache. If the same period was requested within the last minute, we serve the cached version instantly.</li>
                            <li><strong>Load &amp; filter</strong> — Read all snapshots from the JSONL file, parse timestamps, sort chronologically, and filter to the requested time window.</li>
                            <li><strong>Gap detection</strong> — Scan consecutive timestamps for gaps &gt; 2 hours. These become the dashed-line segments on the chart — they represent real outages (Railway restarts, AWS issues), not normal 3-minute intervals.</li>
                            <li><strong>EMA smoothing</strong> — Run an exponential moving average (alpha = 0.15) across each candidate's probability series. This is the biggest smoothing step — each data point becomes 15% raw value + 85% previous smoothed value, which kills jitter while preserving genuine trends.</li>
                            <li><strong>RDP simplification</strong> — The Ramer-Douglas-Peucker algorithm finds which points you can remove without changing the visual shape of the line (within an epsilon tolerance of 0.5 percentage points). A week of data at 3-minute intervals = ~3,360 points per candidate. After RDP, that drops to maybe 200–400 points. Your browser thanks us.</li>
                        </ul>
                        <p>The RDP algorithm is actually kind of elegant. Imagine drawing a straight line from the first data point to the last. Now find whichever intermediate point is farthest from that line. If it's farther than epsilon, that point matters — keep it, and recursively check both halves. If it's closer than epsilon, the whole segment is "flat enough" to represent with just the endpoints. It's O(n log n) on average and perfectly preserves peaks, valleys, and inflection points while throwing away the boring flat stretches.</p>

                        <h3>The Frontend Rendering</h3>
                        <p>The chart itself is rendered with <strong>Chart.js</strong> using a time-scaled x-axis. The data comes in as <code>{x: timestamp, y: probability}</code> pairs, and Chart.js handles the rest. A few important settings:</p>
                        <ul class="method-list">
                            <li><strong>Monotone cubic interpolation</strong> — This is the <code>cubicInterpolationMode: 'monotone'</code> setting. Regular cubic splines can "overshoot" — if a candidate goes from 60% to 62%, a regular spline might draw a curve that briefly dips to 59% between the points. Monotone splines guarantee the curve never exceeds the actual data values. No fake dips, no fake peaks.</li>
                            <li><strong>Tension 0.5</strong> — Controls how curvy the lines are. At 0 you get straight segments (ugly). At 1 you get maximally curvy (too smooth, hides real movement). 0.5 is the sweet spot.</li>
                            <li><strong>Central Time display</strong> — All timestamps are stored in UTC but displayed in Central Time (America/Chicago) using <code>Intl.DateTimeFormat</code>. This handles daylight saving transitions automatically — no hardcoded offsets.</li>
                            <li><strong>Segment styling for gaps</strong> — Chart.js lets you style individual line segments. For each segment, we check if the two endpoints span a known gap period. If they do, the segment gets dashed and faded. This is done per-frame via a callback, so it works even when you zoom or pan.</li>
                        </ul>

                        <h3>What Could Go Wrong (and what we do about it)</h3>
                        <p>A few things have bitten us before, so we built defenses:</p>
                        <ul class="method-list">
                            <li><strong>API timeouts:</strong> Both Manifold and Kalshi calls have 10-second timeouts. If they're slow, we fail fast instead of blocking the scheduler thread.</li>
                            <li><strong>Partial API failure:</strong> If only one API goes down, we still collect what we can, but spike dampening prevents the sudden weight shift from creating chart artifacts.</li>
                            <li><strong>Railway restarts:</strong> The persistent volume survives container restarts. When the app boots, it checks for existing data and picks up where it left off.</li>
                            <li><strong>Corrupt JSONL lines:</strong> The reader skips unparseable lines and logs a warning. One bad line doesn't take down the whole dataset — that's the beauty of line-delimited formats.</li>
                            <li><strong>Duplicate schedulers:</strong> The Gunicorn <code>--preload</code> + <code>sys.argv</code> detection ensures exactly one scraper thread exists in production.</li>
                        </ul>

                        <h3>Dependencies</h3>
                        <p>The whole app runs on five Python packages:</p>
                        <div class="formula-box" style="font-size: 0.95rem;">
                            Flask 2.3.2 &nbsp;&mdash;&nbsp; web framework<br>
                            Werkzeug 2.3.6 &nbsp;&mdash;&nbsp; WSGI utilities (Flask dependency)<br>
                            Requests 2.31.0 &nbsp;&mdash;&nbsp; HTTP client for API calls<br>
                            Gunicorn 21.2.0 &nbsp;&mdash;&nbsp; production WSGI server<br>
                            APScheduler 3.10.4 &nbsp;&mdash;&nbsp; background job scheduling (dev mode)
                        </div>
                        <p>No NumPy, no Pandas, no heavyweight data libraries. The EMA, RDP, and aggregation math are all hand-written in ~100 lines of plain Python. For a project that processes a few hundred data points, there's no reason to import a 30 MB library.</p>

                    </div>
                </div>
            </div>

            <article class="method-section contact-section">
                <h2>Questions?</h2>
                <p>IL9Cast's prediction market aggregation is maintained by <strong>Ryan McComb</strong>, a student at ETHS, as an educational project to help voters understand real-time sentiment in the Illinois 9th Democratic Primary race.</p>
                <p>For questions about the market aggregation methodology or to report data issues, please reach out directly.</p>
            </article>
        </section>
    </div>

    <style>
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            min-height: 100vh;
        }

        .methodology-content-page {
            max-width: 900px;
            margin: 0 auto 4rem;
            padding: 0 2rem;
        }

        /* ===== FOLDOUT STYLES ===== */
        .method-foldout {
            background: rgba(26, 26, 26, 0.5);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 2px solid rgba(230, 126, 34, 0.3);
            border-radius: 12px;
            margin-bottom: 1.5rem;
            overflow: hidden;
        }

        .foldout-trigger {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1.8rem 2.2rem;
            background: none;
            border: none;
            cursor: pointer;
            text-align: left;
            color: inherit;
            transition: background 0.3s ease;
        }

        .foldout-trigger:hover {
            background: rgba(230, 126, 34, 0.06);
        }

        .foldout-trigger-left {
            display: flex;
            align-items: center;
            gap: 1.2rem;
        }

        .foldout-icon {
            width: 44px;
            height: 44px;
            border-radius: 10px;
            background: rgba(230, 126, 34, 0.15);
            border: 1px solid rgba(230, 126, 34, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .foldout-trigger h2 {
            font-family: 'Cormorant Garamond', Georgia, serif;
            font-size: 1.6rem;
            font-weight: 600;
            color: #e67e22;
            margin: 0;
            line-height: 1.3;
        }

        .foldout-desc {
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.45);
            margin: 0.2rem 0 0 0;
            line-height: 1.4;
        }

        .foldout-arrow {
            font-family: 'Inter', sans-serif;
            font-size: 1.6rem;
            font-weight: 300;
            color: rgba(230, 126, 34, 0.6);
            transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            flex-shrink: 0;
            width: 30px;
            text-align: center;
            line-height: 1;
        }

        .foldout-arrow.open {
            transform: rotate(45deg);
        }

        .foldout-body {
            display: grid;
            grid-template-rows: 0fr;
            transition: grid-template-rows 0.5s cubic-bezier(0.34, 1.12, 0.64, 1),
                        opacity 0.4s ease;
            opacity: 0;
        }

        .foldout-body.open {
            grid-template-rows: 1fr;
            opacity: 1;
        }

        .foldout-inner {
            overflow: hidden;
            padding: 0 2.2rem;
        }

        .foldout-body.open .foldout-inner {
            padding-bottom: 2.2rem;
        }

        .foldout-body .foldout-inner {
            border-top: 1px solid rgba(230, 126, 34, 0.15);
            padding-top: 0;
            transition: padding-top 0.4s ease;
        }

        .foldout-body.open .foldout-inner {
            padding-top: 1.8rem;
        }

        /* Active/open foldout border glow */
        .method-foldout.active {
            border-color: rgba(230, 126, 34, 0.5);
            box-shadow: 0 0 20px rgba(230, 126, 34, 0.08);
        }

        /* ===== COMING SOON BLOCK ===== */
        .coming-soon-block {
            text-align: center;
            padding: 2rem 1rem;
        }

        .coming-soon-icon {
            font-size: 2.5rem;
            display: block;
            margin-bottom: 0.8rem;
            opacity: 0.4;
        }

        .coming-soon-block h3 {
            font-family: 'Cormorant Garamond', Georgia, serif;
            font-size: 1.5rem;
            font-weight: 600;
            color: rgba(230, 126, 34, 0.7);
            margin-bottom: 0.8rem;
        }

        .coming-soon-block p {
            color: rgba(255, 255, 255, 0.45);
            max-width: 550px;
            margin: 0 auto;
            line-height: 1.7;
        }

        .coming-soon-block a {
            color: #e67e22;
            text-decoration: underline;
        }

        /* ===== INNER CONTENT STYLES ===== */
        .foldout-inner h3 {
            font-family: 'Cormorant Garamond', Georgia, serif;
            font-size: 1.4rem;
            font-weight: 600;
            margin-top: 2rem;
            margin-bottom: 1rem;
            color: #e67e22;
        }

        .foldout-inner p {
            margin-bottom: 1rem;
            line-height: 1.8;
            color: #c0c0c0;
        }

        .foldout-inner a {
            color: #e67e22;
            text-decoration: underline;
        }

        .foldout-inner a:hover {
            opacity: 0.8;
        }

        .method-list {
            list-style: none;
            padding-left: 0;
            margin: 1rem 0;
        }

        .method-list li {
            margin-bottom: 0.8rem;
            padding-left: 1.5rem;
            position: relative;
            line-height: 1.6;
            color: #c0c0c0;
        }

        .method-list li:before {
            content: "\2192";
            position: absolute;
            left: 0;
            color: #e67e22;
        }

        .formula-box {
            font-family: 'VT323', monospace;
            background: rgba(230, 126, 34, 0.1);
            border-left: 4px solid #e67e22;
            padding: 1.5rem;
            border-radius: 4px;
            margin: 1.5rem 0;
            font-size: 1.1rem;
            color: #e0e0e0;
        }

        /* ===== CONTACT SECTION ===== */
        .method-section {
            background: rgba(26, 26, 26, 0.5);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 2px solid rgba(230, 126, 34, 0.3);
            border-radius: 12px;
            padding: 2.5rem;
            margin-bottom: 2rem;
        }

        .method-section h2 {
            font-family: 'Cormorant Garamond', Georgia, serif;
            font-size: 2rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            color: #e67e22;
        }

        .method-section p {
            margin-bottom: 1rem;
            line-height: 1.8;
            color: #c0c0c0;
        }

        .contact-section {
            border-color: rgba(230, 126, 34, 0.5);
        }

        /* ===== RESPONSIVE ===== */
        @media (max-width: 600px) {
            .foldout-trigger {
                padding: 1.2rem 1.4rem;
            }
            .foldout-trigger h2 {
                font-size: 1.25rem;
            }
            .foldout-inner {
                padding: 0 1.4rem;
            }
            .foldout-body.open .foldout-inner {
                padding-bottom: 1.4rem;
            }
            .foldout-icon {
                width: 36px;
                height: 36px;
            }
        }
    </style>

    <script>
        function toggleFoldout(id) {
            const body = document.getElementById('foldout-body-' + id);
            const arrow = document.getElementById('foldout-arrow-' + id);
            const foldout = document.getElementById('foldout-' + id);
            const isOpen = body.classList.contains('open');

            body.classList.toggle('open');
            arrow.classList.toggle('open');
            foldout.classList.toggle('active');
        }

        // GRID BACKGROUND - Static, no mouse interaction
        const canvas = document.getElementById('grid-canvas');
        const ctx = canvas.getContext('2d');
        const gridSize = 40;

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            drawGrid();
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const isDarkMode = document.body.classList.contains('dark-mode');
            ctx.strokeStyle = isDarkMode ? 'rgba(255, 255, 255, 0.08)' : 'rgba(0, 0, 0, 0.055)';
            ctx.lineWidth = 1;

            // Draw horizontal lines
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw vertical lines
            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
        }

        drawGrid();
    </script>
</body>
</html>
